#+TITLE: ByteHot Getting Started Guide
#+AUTHOR: ByteHot Development Team
#+DATE: [2025-06-19]

Welcome to ByteHot! This comprehensive guide will help you get started with ByteHot, a revolutionary JVM agent that enables bytecode hot-swapping at runtime, allowing you to modify your Java code without restarting your application.

* Table of Contents

1. [[#what-is-bytehot][What is ByteHot?]]
2. [[#prerequisites][Prerequisites]]
3. [[#installation][Installation]]
4. [[#quick-start][Quick Start]]
5. [[#configuration][Configuration]]
6. [[#basic-usage][Basic Usage]]
7. [[#advanced-features][Advanced Features]]
8. [[#troubleshooting][Troubleshooting]]
9. [[#best-practices][Best Practices]]
10. [[#examples][Examples]]

* What is ByteHot?
:PROPERTIES:
:CUSTOM_ID: what-is-bytehot
:END:

ByteHot is a JVM agent that revolutionizes Java development by enabling *hot-swapping* - the ability to modify your Java classes at runtime without restarting your application. This dramatically improves development productivity by eliminating the time-consuming restart cycle.

** Key Features

- üî• *Real-time Hot-swapping*: Modify classes while your application runs
- üìÅ *Automatic File Watching*: Detects changes to =.class= files automatically  
- üõ°Ô∏è *Safe Bytecode Validation*: Ensures only compatible changes are applied
- üìä *Event-driven Architecture*: Complete audit trail of all changes
- üë§ *User-aware Operations*: Tracks who made what changes when
- üß™ *Revolutionary Testing*: Event-driven testing framework for reliable tests
- üîç *Flow Detection*: Automatically discovers and documents your development patterns
- üêõ *Advanced Bug Reporting*: Captures complete event context for reproducible bug reports

** How It Works

ByteHot uses a sophisticated event-driven architecture based on Domain-Driven Design (DDD) and Hexagonal Architecture principles:

1. *File System Monitoring*: Watches your compiled =.class= files for changes
2. *Bytecode Analysis*: Validates that changes are compatible with hot-swapping
3. *Hot-swap Operations*: Uses JVM instrumentation to redefine classes at runtime
4. *Instance Management*: Updates existing object instances with new behavior
5. *Event Sourcing*: Records all operations as events for complete auditability

* Prerequisites
:PROPERTIES:
:CUSTOM_ID: prerequisites
:END:

** System Requirements

- *Java 17+*: ByteHot requires Java 17 or later
- *Maven 3.6+*: For building from source
- *Git*: For version control (if building from source)

** Development Environment

- *IDE*: Any Java IDE (IntelliJ IDEA, Eclipse, VS Code with Java extensions)
- *Build Tool*: Maven or Gradle project structure
- *Operating System*: Linux, macOS, or Windows

** Supported Frameworks

ByteHot works with any Java application, including:
- *Spring Boot* applications
- *Jakarta EE* applications  
- *Standalone* Java applications
- *Microservices* architectures

* Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:

** Option 1: Download Pre-built JAR (Recommended)

1. Download the latest ByteHot agent JAR from the [[https://github.com/rydnr/bytehot/releases][releases page]]
2. Save it to a convenient location (e.g., =~/tools/bytehot-agent.jar=)

** Option 2: Build from Source

#+BEGIN_SRC bash
# Clone the repository
git clone https://github.com/rydnr/bytehot.git
cd bytehot

# Build the project
mvn clean package

# The agent JAR will be at: bytehot/target/bytehot-agent.jar
#+END_SRC

* Quick Start
:PROPERTIES:
:CUSTOM_ID: quick-start
:END:

** 1. Create a Simple Java Application

#+BEGIN_SRC java
// src/main/java/com/example/HelloWorld.java
package com.example;

public class HelloWorld {
    public static void main(String[] args) throws InterruptedException {
        HelloWorld app = new HelloWorld();
        while (true) {
            app.sayHello();
            Thread.sleep(2000);
        }
    }
    
    public void sayHello() {
        System.out.println("Hello, World! Current time: " + System.currentTimeMillis());
    }
}
#+END_SRC

** 2. Compile Your Application

#+BEGIN_SRC bash
# Compile your Java application
javac -d target/classes src/main/java/com/example/HelloWorld.java
#+END_SRC

** 3. Run with ByteHot Agent

#+BEGIN_SRC bash
# Run with ByteHot agent attached (system properties)
java -javaagent:target/bytehot-latest-SNAPSHOT-shaded.jar \
     -Dbytehot.watch.paths=target/classes \
     -cp target/classes \
     com.example.HelloWorld

# Alternative: Using YAML configuration file
java -javaagent:target/bytehot-latest-SNAPSHOT-shaded.jar \
     -Dbhconfig=src/main/resources/examples/bytehot-simple.yml \
     -cp target/classes \
     com.example.HelloWorld
#+END_SRC

** 4. Make Live Changes

1. *Keep the application running* from step 3
2. *Modify the =sayHello()= method*:

#+BEGIN_SRC java
public void sayHello() {
    System.out.println("üî• Hot-swapped! Hello from ByteHot! Time: " + System.currentTimeMillis());
}
#+END_SRC

3. *Recompile* (the agent will detect the change automatically):

#+BEGIN_SRC bash
javac -d target/classes src/main/java/com/example/HelloWorld.java
#+END_SRC

4. *Watch the magic happen* - your running application will start using the new method without restarting!

* Configuration
:PROPERTIES:
:CUSTOM_ID: configuration
:END:

ByteHot supports multiple configuration approaches with a clear priority order.

** Configuration Methods

ByteHot loads configuration in this priority order:
1. *System Properties* (~-Dbytehot.*~)
2. *Environment Variables* (~BYTEHOT_*~)
3. *External YAML file* (~-Dbhconfig=path/to/file.yml~)
4. *Classpath YAML files* (~bytehot.yml~, ~application.yml~)
5. *Default configuration*

** System Properties

| Property | Description | Default | Example |
|----------|-------------|---------|---------|
| =bytehot.watch.paths= | Directories to watch for changes | =target/classes= | =target/classes,build/classes= |
| =bytehot.watch.patterns= | File patterns to monitor | =*.class= | =**/*.class,**/*.jar= |
| =bhconfig= | Path to external YAML configuration file | None | =/path/to/bytehot.yml= |
| =bytehot.user.id= | Explicit user identification | Auto-detected | =john.doe@company.com= |
| =bytehot.session.id= | Session identifier | Auto-generated | =dev-session-123= |
| =bytehot.logging.level= | Logging verbosity | =INFO= | =DEBUG= |
| =bytehot.validation.strict= | Strict bytecode validation | =true= | =false= |

** Environment Variables

#+BEGIN_SRC bash
export BYTEHOT_WATCH_PATHS="target/classes,build/classes"
export BYTEHOT_WATCH_PATTERNS="**/*.class"
export BYTEHOT_USER_ID="developer@company.com"
export BYTEHOT_LOGGING_LEVEL="DEBUG"
#+END_SRC

** YAML Configuration

Create a ~bytehot.yml~ file and use ~-Dbhconfig~ to specify its location:

#+BEGIN_SRC yaml
bytehot:
  watch:
    - path: "target/classes"
      patterns: ["*.class"]
      recursive: true
    - path: "build/classes"
      patterns: ["*.class", "*.jar"]
      recursive: true
#+END_SRC

Use it with:
#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar -Dbhconfig=/path/to/bytehot.yml ...
#+END_SRC

** Configuration Examples

*** Spring Boot Application

#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar \
     -Dbytehot.watch.paths=target/classes \
     -Dbytehot.user.id=$(git config user.email) \
     -jar target/my-spring-app.jar
#+END_SRC

*** Multi-module Maven Project

#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar \
     -Dbytehot.watch.paths=module1/target/classes,module2/target/classes \
     -Dbytehot.watch.patterns=**/*.class \
     -cp "module1/target/classes:module2/target/classes" \
     com.example.MainApplication
#+END_SRC

*** Gradle Project

#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar \
     -Dbytehot.watch.paths=build/classes/java/main \
     -Dbytehot.watch.patterns=**/*.class \
     -cp build/classes/java/main \
     com.example.Application
#+END_SRC

*** Using Sample Configuration Files

ByteHot includes sample configuration files you can copy:

#+BEGIN_SRC bash
# Copy sample configuration
cp src/main/resources/examples/bytehot.yml ./my-bytehot-config.yml

# Use it
java -javaagent:bytehot-agent.jar \
     -Dbhconfig=./my-bytehot-config.yml \
     -cp target/classes \
     com.example.Application
#+END_SRC

* Basic Usage
:PROPERTIES:
:CUSTOM_ID: basic-usage
:END:

** File System Monitoring

ByteHot automatically monitors specified directories for =.class= file changes:

#+BEGIN_SRC bash
# Monitor single directory
-Dbytehot.watch.paths=target/classes

# Monitor multiple directories
-Dbytehot.watch.paths=target/classes,target/test-classes

# Custom patterns
-Dbytehot.watch.patterns=**/*.class,**/service/**/*.class
#+END_SRC

** User Identification

ByteHot automatically identifies users through multiple sources:

1. *Explicit configuration*: =-Dbytehot.user.id=john.doe@company.com=
2. *Git configuration*: Uses =git config user.email=
3. *System user*: Falls back to system username + hostname
4. *Anonymous*: Generates anonymous identifier if needed

** Session Management

ByteHot creates user sessions to track development activities:

#+BEGIN_SRC bash
# Explicit session ID
-Dbytehot.session.id=feature-development-session

# Auto-generated session (default)
# Sessions include: user, timestamp, environment info
#+END_SRC

** Hot-swap Lifecycle

Understanding the hot-swap process helps you work effectively with ByteHot:

1. *File Change Detection*: ByteHot detects =.class= file modifications
2. *Bytecode Analysis*: Validates the changes are hot-swap compatible
3. *Class Redefinition*: Uses JVM instrumentation to update the class
4. *Instance Updates*: Updates existing object instances with new behavior
5. *Event Recording*: Records the entire operation as events for audit trails

** Compatible Changes

ByteHot supports these types of changes:

‚úÖ *Supported Changes*:
- Method body modifications
- Adding new methods
- Adding new fields (with caution)
- Changing method implementations
- Adding static methods
- Modifying static initializers

‚ùå *Unsupported Changes*:
- Changing method signatures
- Removing methods
- Changing class hierarchy
- Modifying constructor signatures
- Adding/removing interfaces

* Advanced Features
:PROPERTIES:
:CUSTOM_ID: advanced-features
:END:

** Event-Driven Testing

ByteHot includes a revolutionary testing framework that uses events:

#+BEGIN_SRC java
@Test
void shouldUpdateInstancesAfterHotSwap() {
    // Given: System state from real events
    given()
        .event(new ByteHotAgentAttached("agent-123"))
        .event(new ClassFileChanged("/path/MyClass.class"));
    
    // When: The event we want to test
    when()
        .event(new InstanceUpdateRequested("MyClass", 2));
    
    // Then: Expected resulting events
    then()
        .expectEvent(InstancesUpdated.class)
        .withUpdatedCount(2)
        .withSuccessful(true);
}
#+END_SRC

** Flow Detection

ByteHot automatically discovers your development patterns:

#+BEGIN_SRC bash
# Enable flow detection
-Dbytehot.flow.detection.enabled=true

# Configure pattern analysis
-Dbytehot.flow.analysis.window=PT30M  # 30 minutes
-Dbytehot.flow.confidence.threshold=0.8
#+END_SRC

** User Analytics

Track your development productivity:

#+BEGIN_SRC java
// ByteHot automatically tracks:
// - Hot-swap success rates
// - Time saved by avoiding restarts  
// - Most frequently modified classes
// - Development patterns and workflows
#+END_SRC

** Bug Reporting with Event Context

When errors occur, ByteHot captures complete context:

#+BEGIN_SRC java
try {
    // Your code
} catch (Exception e) {
    // ByteHot automatically captures:
    // - Complete event history leading to the error
    // - User context and session information
    // - System state snapshot
    // - Reproducible test case generation
}
#+END_SRC

* Troubleshooting
:PROPERTIES:
:CUSTOM_ID: troubleshooting
:END:

** Common Issues

*** 1. Agent Not Attaching

*Problem*: ByteHot agent doesn't seem to be working

*Solutions*:
#+BEGIN_SRC bash
# Verify agent path is correct
ls -la path/to/bytehot-agent.jar

# Check Java version
java -version  # Should be 17+

# Enable debug logging
-Dbytehot.logging.level=DEBUG
#+END_SRC

*** 2. Classes Not Hot-swapping

*Problem*: Changes aren't being applied

*Solutions*:
#+BEGIN_SRC bash
# Verify watch paths are correct
-Dbytehot.watch.paths=target/classes  # Check this matches your build output

# Check file permissions
ls -la target/classes/com/example/

# Verify bytecode compatibility
# Make sure you're only changing method bodies, not signatures
#+END_SRC

*** 3. File System Events Not Detected

*Problem*: File changes aren't being detected

*Solutions*:
#+BEGIN_SRC bash
# Check if patterns match your files
-Dbytehot.watch.patterns=**/*.class

# Verify directory exists and is writable
test -d target/classes && test -w target/classes

# Check for filesystem-specific issues (Docker, network drives)
# Use absolute paths if needed
-Dbytehot.watch.paths=/absolute/path/to/classes
#+END_SRC

*** 4. Hot-swap Rejected

*Problem*: ByteHot rejects your changes

*Diagnosis*:
- Check logs for validation errors
- Ensure you're only modifying method bodies
- Avoid changing method signatures or class structure

*Solutions*:
#+BEGIN_SRC java
// Good: Changing method implementation
public void process() {
    // New implementation
    logger.info("Updated processing logic");
}

// Bad: Changing method signature
// public void process(String param) { ... }  // Don't do this
#+END_SRC

*** 5. Configuration Not Loading

*Problem*: ByteHot seems to ignore your configuration

*Solutions*:
#+BEGIN_SRC bash
# Verify system properties syntax
java -Dbytehot.watch.paths=target/classes ...  # Correct
java -D bytehot.watch.paths=target/classes ... # Wrong (space after -D)

# Check YAML file path is absolute or relative to working directory
-Dbhconfig=/absolute/path/to/bytehot.yml        # Absolute path
-Dbhconfig=./relative/path/to/bytehot.yml       # Relative path

# Verify YAML syntax is correct
# Use a YAML validator or copy from examples/
cp src/main/resources/examples/bytehot-simple.yml ./test.yml

# Test with minimal configuration first
-Dbytehot.watch.paths=target/classes  # Start simple
#+END_SRC

*Diagnosis*:
#+BEGIN_SRC bash
# Check if directories exist
ls -la target/classes

# Verify JAR path is correct
ls -la target/bytehot-*-shaded.jar

# Test with absolute paths
-Dbytehot.watch.paths=/full/path/to/target/classes
#+END_SRC

** Debug Mode

Enable comprehensive debugging:

#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar \
     -Dbytehot.logging.level=DEBUG \
     -Dbytehot.validation.verbose=true \
     -Dbytehot.events.trace=true \
     -cp target/classes \
     com.example.Application
#+END_SRC

** Log Analysis

ByteHot provides detailed logs:

#+BEGIN_EXAMPLE
[ByteHot] Agent attached successfully
[ByteHot] Watching: target/classes
[ByteHot] User identified: john.doe@company.com
[ByteHot] Session started: session-abc123
[ByteHot] File change detected: target/classes/com/example/Service.class
[ByteHot] Bytecode validation: PASSED
[ByteHot] Hot-swap executed successfully
[ByteHot] Instances updated: 3 objects
#+END_EXAMPLE

* Best Practices
:PROPERTIES:
:CUSTOM_ID: best-practices
:END:

** 1. Development Workflow

#+BEGIN_SRC bash
# Recommended development setup
export BYTEHOT_AGENT="path/to/bytehot-agent.jar"
export BYTEHOT_WATCH="target/classes"

# Create an alias for easy startup
alias run-with-bytehot='java -javaagent:$BYTEHOT_AGENT -Dbytehot.watch.paths=$BYTEHOT_WATCH'

# Use it in your projects
run-with-bytehot -cp target/classes com.example.Application
#+END_SRC

** 2. IDE Integration

*** IntelliJ IDEA

1. Go to *Run/Debug Configurations*
2. Add VM options:
#+BEGIN_EXAMPLE
-javaagent:path/to/bytehot-agent.jar
-Dbytehot.watch.paths=target/classes
-Dbytehot.user.id=${USER}@${DOMAIN}
#+END_EXAMPLE
3. Enable *Build project automatically*
4. Enable *Compiler > Build project automatically*

*** Eclipse

1. Right-click project ‚Üí *Run As* ‚Üí *Run Configurations*
2. Go to *Arguments* tab
3. Add to *VM arguments*:
#+BEGIN_EXAMPLE
-javaagent:path/to/bytehot-agent.jar
-Dbytehot.watch.paths=target/classes
#+END_EXAMPLE

*** VS Code

Add to =.vscode/launch.json=:

#+BEGIN_SRC json
{
    "type": "java",
    "request": "launch",
    "mainClass": "com.example.Application",
    "vmArgs": [
        "-javaagent:path/to/bytehot-agent.jar",
        "-Dbytehot.watch.paths=target/classes"
    ]
}
#+END_SRC

** 3. Team Development

#+BEGIN_SRC bash
# Share ByteHot configuration in your project
# Create scripts/run-dev.sh
#!/bin/bash
BYTEHOT_AGENT="tools/bytehot-agent.jar"
MAIN_CLASS="com.example.Application"

java -javaagent:$BYTEHOT_AGENT \
     -Dbytehot.watch.paths=target/classes \
     -Dbytehot.user.id=$(git config user.email) \
     -cp target/classes \
     $MAIN_CLASS
#+END_SRC

** 4. Testing Strategy

#+BEGIN_SRC java
// Use ByteHot's event-driven testing for better tests
public class MyServiceTest extends EventDrivenTestSupport {
    
    @Test
    void shouldHandleUserRequest() {
        given()
            .event(new UserRegistered(userId))
            .event(new ServiceInitialized());
        
        when()
            .event(new ProcessUserRequest(userId, request));
        
        then()
            .expectEvent(RequestProcessed.class)
            .withUserId(userId)
            .withSuccessful(true);
    }
}
#+END_SRC

** 5. Production Considerations

*‚ö†Ô∏è Important*: ByteHot is designed for development environments.

For production:
- *Never* use ByteHot in production environments
- Use proper deployment processes for production changes
- Consider using ByteHot for *staging/testing* environments only

** 6. Performance Tips

#+BEGIN_SRC bash
# Optimize file watching for large projects
-Dbytehot.watch.patterns=**/service/**/*.class,**/controller/**/*.class

# Exclude test classes from watching
-Dbytehot.watch.patterns=**/*.class,!**/*Test.class

# Tune validation settings
-Dbytehot.validation.timeout=5000  # 5 seconds
-Dbytehot.hotswap.retries=3
#+END_SRC

* Examples
:PROPERTIES:
:CUSTOM_ID: examples
:END:

** Example 1: Spring Boot REST API

#+BEGIN_SRC java
// src/main/java/com/example/UserController.java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        // Initial implementation
        return ResponseEntity.ok(userService.findById(id));
    }
}
#+END_SRC

*Run with ByteHot*:
#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar \
     -Dbytehot.watch.paths=target/classes \
     -jar target/my-spring-app.jar
#+END_SRC

*Hot-swap the endpoint*:
#+BEGIN_SRC java
@GetMapping("/{id}")
public ResponseEntity<User> getUser(@PathVariable Long id) {
    // Enhanced implementation with caching
    User user = cacheService.get(id);
    if (user == null) {
        user = userService.findById(id);
        cacheService.put(id, user);
    }
    return ResponseEntity.ok(user);
}
#+END_SRC

Recompile and watch your running API immediately use the new caching logic!

** Example 2: Background Service

#+BEGIN_SRC java
// com/example/DataProcessor.java
@Component
public class DataProcessor {
    
    @Scheduled(fixedRate = 5000)
    public void processData() {
        // Original processing logic
        List<Data> data = dataRepository.findUnprocessed();
        data.forEach(this::processItem);
    }
    
    private void processItem(Data item) {
        // Simple processing
        item.setStatus("PROCESSED");
        dataRepository.save(item);
    }
}
#+END_SRC

*Hot-swap to add error handling*:
#+BEGIN_SRC java
private void processItem(Data item) {
    try {
        // Enhanced processing with validation
        if (item.isValid()) {
            item.setStatus("PROCESSED");
            item.setProcessedAt(Instant.now());
        } else {
            item.setStatus("VALIDATION_FAILED");
            item.setErrorMessage("Invalid data format");
        }
        dataRepository.save(item);
    } catch (Exception e) {
        logger.error("Processing failed for item {}", item.getId(), e);
        item.setStatus("ERROR");
        item.setErrorMessage(e.getMessage());
        dataRepository.save(item);
    }
}
#+END_SRC

** Example 3: Event-Driven Testing

#+BEGIN_SRC java
public class HotSwapIntegrationTest extends EventDrivenTestSupport {
    
    @Test
    void shouldCompleteFullHotSwapFlow() {
        // Given: ByteHot is running and monitoring files
        given()
            .event(new ByteHotAgentAttached("test-agent"))
            .event(new WatchPathConfigured("target/test-classes", "**/*.class"))
            .event(new UserSessionStarted(UserId.of("test-user")));
        
        // When: A class file is modified
        when()
            .event(new ClassFileChanged("target/test-classes/TestService.class", "TestService", 2048));
        
        // Then: Complete hot-swap flow should execute
        then()
            .expectSequence()
                .then(ClassMetadataExtracted.class)
                .then(BytecodeValidated.class)
                .then(HotSwapRequested.class)
                .then(ClassRedefinitionSucceeded.class)
                .then(InstancesUpdated.class)
            .inOrder()
            .expectEvent(UserStatisticsUpdated.class)
                .withSuccessfulHotSwaps(1);
    }
}
#+END_SRC

* Next Steps

Now that you're familiar with ByteHot basics:

1. *Try the Quick Start* example with your own application
2. *Explore Advanced Features* like flow detection and user analytics
3. *Integrate with your IDE* for seamless development
4. *Read the Architecture Documentation* to understand ByteHot's design
5. *Join the Community* and contribute to ByteHot's development

** Additional Resources

- üìö *[[docs/architecture.html][Architecture Guide]]*: Deep dive into ByteHot's design
- üîß *[[javadocs/][API Documentation]]*: Complete API reference
- üéØ *[[examples/][Examples Repository]]*: More comprehensive examples
- üêõ *[[https://github.com/rydnr/bytehot/issues][Issue Tracker]]*: Report bugs or request features
- üí¨ *[[https://github.com/rydnr/bytehot/discussions][Discussions]]*: Community support and ideas

** Contributing

ByteHot is open source and welcomes contributions:

#+BEGIN_SRC bash
# Fork the repository
git clone https://github.com/your-username/bytehot.git

# Create a feature branch
git checkout -b feature/amazing-feature

# Make your changes and test
mvn test

# Follow ByteHot's commit conventions
git commit -m "‚ú® Add amazing feature

Implement amazing new functionality that improves developer experience.

ü§ñ Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: YourName <your.email@domain.com>"

# Submit a pull request
#+END_SRC

Welcome to the ByteHot community! üî• Happy hot-swapping! üöÄ