#+TITLE: ByteHot Getting Started Guide
#+AUTHOR: ByteHot Development Team
#+DATE: [2025-06-19]

Welcome to ByteHot! This comprehensive guide will help you get started with ByteHot, a revolutionary JVM agent that enables bytecode hot-swapping at runtime, allowing you to modify your Java code without restarting your application.

* Table of Contents

1. [[#what-is-bytehot][What is ByteHot?]]
2. [[#prerequisites][Prerequisites]]
3. [[#installation][Installation]]
4. [[#quick-start][Quick Start]]
5. [[#plugin-integration][Plugin Integration]]
6. [[#configuration][Configuration]]
7. [[#basic-usage][Basic Usage]]
8. [[#advanced-features][Advanced Features]]
9. [[#troubleshooting][Troubleshooting]]
10. [[#best-practices][Best Practices]]
11. [[#examples][Examples]]

* What is ByteHot?
:PROPERTIES:
:CUSTOM_ID: what-is-bytehot
:END:

ByteHot is a JVM agent that revolutionizes Java development by enabling *hot-swapping* - the ability to modify your Java classes at runtime without restarting your application. This dramatically improves development productivity by eliminating the time-consuming restart cycle.

** Key Features

- üî• *Real-time Hot-swapping*: Modify classes while your application runs
- üìÅ *Automatic File Watching*: Detects changes to =.class= files automatically  
- üõ°Ô∏è *Safe Bytecode Validation*: Ensures only compatible changes are applied
- üìä *Event-driven Architecture*: Complete audit trail of all changes
- üë§ *User-aware Operations*: Tracks who made what changes when
- üß™ *Revolutionary Testing*: Event-driven testing framework for reliable tests
- üîç *Flow Detection*: Automatically discovers and documents your development patterns
- üêõ *Advanced Bug Reporting*: Captures complete event context for reproducible bug reports

** How It Works

ByteHot uses a sophisticated event-driven architecture based on Domain-Driven Design (DDD) and Hexagonal Architecture principles:

1. *File System Monitoring*: Watches your compiled =.class= files for changes
2. *Bytecode Analysis*: Validates that changes are compatible with hot-swapping
3. *Hot-swap Operations*: Uses JVM instrumentation to redefine classes at runtime
4. *Instance Management*: Updates existing object instances with new behavior
5. *Event Sourcing*: Records all operations as events for complete auditability

* Prerequisites
:PROPERTIES:
:CUSTOM_ID: prerequisites
:END:

** System Requirements

- *Java 17+*: ByteHot requires Java 17 or later
- *Maven 3.6+*: For building from source
- *Git*: For version control (if building from source)

** Development Environment

- *IDE*: Any Java IDE (IntelliJ IDEA, Eclipse, VS Code with Java extensions)
- *Build Tool*: Maven or Gradle project structure
- *Operating System*: Linux, macOS, or Windows

** Supported Frameworks

ByteHot works with any Java application, including:
- *Spring Boot* applications
- *Jakarta EE* applications  
- *Standalone* Java applications
- *Microservices* architectures

* Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:

** Option 1: Download Pre-built JAR (Recommended)

1. Download the latest ByteHot agent JAR from the [[https://github.com/rydnr/bytehot/releases][releases page]]
2. Save it to a convenient location (e.g., =~/tools/bytehot-agent.jar=)

** Option 2: Build from Source

#+BEGIN_SRC bash
# Clone the repository
git clone https://github.com/rydnr/bytehot.git
cd bytehot

# Build the project
mvn clean package

# The agent JAR will be at: bytehot/target/bytehot-agent.jar
#+END_SRC

* Quick Start
:PROPERTIES:
:CUSTOM_ID: quick-start
:END:

** 1. Create a Simple Java Application

#+BEGIN_SRC java
// src/main/java/com/example/HelloWorld.java
package com.example;

public class HelloWorld {
    public static void main(String[] args) throws InterruptedException {
        HelloWorld app = new HelloWorld();
        while (true) {
            app.sayHello();
            Thread.sleep(2000);
        }
    }
    
    public void sayHello() {
        System.out.println("Hello, World! Current time: " + System.currentTimeMillis());
    }
}
#+END_SRC

** 2. Compile Your Application

#+BEGIN_SRC bash
# Compile your Java application
javac -d target/classes src/main/java/com/example/HelloWorld.java
#+END_SRC

** 3. Run with ByteHot Agent

#+BEGIN_SRC bash
# Run with ByteHot agent attached (system properties)
java -javaagent:target/bytehot-latest-SNAPSHOT-shaded.jar \
     -Dbytehot.watch.paths=target/classes \
     -cp target/classes \
     com.example.HelloWorld

# Alternative: Using YAML configuration file
java -javaagent:target/bytehot-latest-SNAPSHOT-shaded.jar \
     -Dbhconfig=src/main/resources/examples/bytehot-simple.yml \
     -cp target/classes \
     com.example.HelloWorld
#+END_SRC

** 4. Make Live Changes

1. *Keep the application running* from step 3
2. *Modify the =sayHello()= method*:

#+BEGIN_SRC java
public void sayHello() {
    System.out.println("üî• Hot-swapped! Hello from ByteHot! Time: " + System.currentTimeMillis());
}
#+END_SRC

3. *Recompile* (the agent will detect the change automatically):

#+BEGIN_SRC bash
javac -d target/classes src/main/java/com/example/HelloWorld.java
#+END_SRC

4. *Watch the magic happen* - your running application will start using the new method without restarting!

* Plugin Integration
:PROPERTIES:
:CUSTOM_ID: plugin-integration
:END:

For production development workflows, ByteHot provides plugins for popular build tools and IDEs that automate the setup and provide enhanced developer experience.

** Maven Plugin (Recommended for Maven Projects)

The ByteHot Maven Plugin provides zero-configuration live mode activation:

*** Quick Setup

1. Add the plugin to your =pom.xml=:

#+BEGIN_SRC xml
<build>
  <plugins>
    <plugin>
      <groupId>org.acmsl</groupId>
      <artifactId>bytehot-maven-plugin</artifactId>
      <version>latest-SNAPSHOT</version>
    </plugin>
  </plugins>
</build>
#+END_SRC

2. Start live mode with a single command:

#+BEGIN_SRC bash
# Zero-configuration - automatically detects main class and classpath
mvn bytehot:live

# Or with custom main class
mvn bytehot:live -Dbytehot.mainClass=com.example.MyApp

# Dry run to see what would be executed
mvn bytehot:live -Dbytehot.dryRun=true
#+END_SRC

*** Key Features
- *Automatic main class detection* (>90% success rate)
- *Zero-configuration setup* for standard Maven projects
- *Multi-module project support*
- *Classpath auto-building* from project dependencies
- *Agent auto-discovery* in local repository
- *Spring Boot application support*

** Gradle Plugin (Recommended for Gradle Projects)

The ByteHot Gradle Plugin provides seamless integration with Gradle's build lifecycle:

*** Quick Setup

1. Add the plugin to your =build.gradle=:

#+BEGIN_SRC gradle
plugins {
    id 'java'
    id 'application'
    id 'org.acmsl.bytehot' version 'latest-SNAPSHOT'
}

application {
    mainClass = 'com.example.Application'
}
#+END_SRC

2. Start live mode with a single command:

#+BEGIN_SRC bash
# Zero-configuration - automatically detects main class and classpath
./gradlew live

# Dry run to see what would be executed
./gradlew live -Pbytehot.dryRun=true

# With custom configuration
./gradlew live -Pbytehot.verbose=true
#+END_SRC

*** Advanced Configuration

#+BEGIN_SRC gradle
bytehot {
    enabled = true
    verbose = true
    mainClass = 'com.example.CustomApp'  // Override detection
    jvmArgs = ['-Xmx512m', '-Dspring.profiles.active=dev']
    programArgs = ['--debug', '--port=8080']
}
#+END_SRC

*** Key Features
- *Automatic main class detection* from application plugin configuration
- *Zero-configuration setup* for standard Gradle projects
- *Complete classpath building* from project dependencies
- *Agent auto-discovery* in local repository
- *Task integration* with Gradle's build lifecycle
- *Property override support* via =-P= command line options

** IntelliJ IDEA Plugin (Recommended for IntelliJ Users)

The ByteHot IntelliJ Plugin provides native IDE integration with visual feedback:

*** Installation

1. Install from JetBrains Marketplace:
   - Go to =File ‚Üí Settings ‚Üí Plugins=
   - Search for "ByteHot" 
   - Click =Install=

2. Or build from source:
   #+BEGIN_SRC bash
   cd bytehot-intellij-plugin
   mvn package
   # Install the generated JAR in IntelliJ
   #+END_SRC

*** Usage

1. *One-click activation*: Click the "Start Live Mode" toolbar button
2. *Visual feedback*: Real-time hot-swap notifications in the editor
3. *Project analysis*: Automatic detection of main class and project structure
4. *Process management*: Integrated start/stop controls with lifecycle management

*** Key Features
- *Native IDE integration* with IntelliJ's UI
- *Visual hot-swap indicators* and notifications
- *Automatic project analysis* and configuration
- *Integrated tool window* for status monitoring
- *Zero-configuration activation* for most projects

** Manual Setup (Advanced Users)

For custom setups or when plugins aren't available:

#+BEGIN_SRC bash
# Manual agent attachment with explicit configuration
java -javaagent:bytehot-application-latest-SNAPSHOT-agent.jar \
     -Dbytehot.watch.paths=target/classes \
     -Dbytehot.user.id=$(git config user.email) \
     -cp target/classes \
     com.example.Application
#+END_SRC

** Eclipse Plugin (For Eclipse IDE Users)

The ByteHot Eclipse Plugin provides seamless integration with the Eclipse IDE ecosystem:

*** Installation from Eclipse Marketplace

1. Install from Eclipse Marketplace:
   - Go to =Help ‚Üí Eclipse Marketplace=
   - Search for "ByteHot" 
   - Click =Install=
   - Restart Eclipse when prompted

2. Or install from update site:
   #+BEGIN_SRC
   Help ‚Üí Install New Software
   Add Site: https://bytehot.acmsl.org/eclipse-update-site
   Select: ByteHot Eclipse Plugin
   #+END_SRC

*** Usage and Features

1. *Project Setup*: Right-click project ‚Üí =ByteHot ‚Üí Enable Live Mode=
2. *Automatic Detection*: Plugin automatically detects:
   - Main class from run configurations
   - Project classpath and dependencies
   - Output directories (=target/classes=, =bin/=)
   - Framework configurations (Spring, Maven, Gradle)

3. *Visual Integration*:
   - *Status indicators* in Package Explorer showing hot-swap enabled classes
   - *Console integration* with ByteHot event logging
   - *Progress views* showing hot-swap operations in real-time
   - *Problem markers* for hot-swap validation issues

*** Advanced Configuration

#+BEGIN_SRC xml
<!-- .project file configuration -->
<projectDescription>
  <buildSpec>
    <buildCommand>
      <name>org.acmsl.bytehot.eclipse.builder</name>
      <arguments>
        <dictionary>
          <key>watchPaths</key>
          <value>bin/main,target/classes</value>
        </dictionary>
      </arguments>
    </buildCommand>
  </buildSpec>
</projectDescription>
#+END_SRC

*** Key Features
- *Workspace-aware configuration* with automatic project detection
- *Build integration* with Eclipse's incremental Java compiler
- *Debug preservation* maintaining breakpoints across hot-swaps
- *Team synchronization* sharing ByteHot settings across team members
- *Multi-project support* for complex workspace setups

** VS Code Extension (For Visual Studio Code Users)

The ByteHot VS Code Extension brings hot-swapping capabilities to the popular cross-platform editor:

*** Installation from VS Code Marketplace

1. Install from Marketplace:
   - Open VS Code
   - Go to =Extensions= (Ctrl+Shift+X)
   - Search for "ByteHot"
   - Click =Install=

2. Or install via command line:
   #+BEGIN_SRC bash
   code --install-extension acmsl.bytehot-vscode
   #+END_SRC

*** Quick Setup

1. *Command Palette Integration*:
   - =Ctrl+Shift+P= ‚Üí "ByteHot: Start Live Mode"
   - =Ctrl+Shift+P= ‚Üí "ByteHot: Stop Live Mode" 
   - =Ctrl+Shift+P= ‚Üí "ByteHot: Show Status"

2. *Automatic Project Analysis*:
   - Detects =pom.xml=, =build.gradle=, or =.classpath= files
   - Identifies main class from =launch.json= configurations
   - Configures watch paths based on build tool conventions

3. *Settings Configuration*:
   #+BEGIN_SRC json
   // .vscode/settings.json
   {
     "bytehot.enabled": true,
     "bytehot.autoStart": true,
     "bytehot.watchPaths": ["target/classes", "build/classes"],
     "bytehot.jvmArgs": ["-Xmx512m"],
     "bytehot.logLevel": "INFO"
   }
   #+END_SRC

*** Advanced Features

**** Language Server Integration
#+BEGIN_SRC json
// .vscode/launch.json
{
  "type": "java",
  "request": "launch",
  "mainClass": "com.example.Application",
  "vmArgs": [
    "-javaagent:${workspaceFolder}/.vscode/bytehot-agent.jar",
    "-Dbytehot.watch.paths=${workspaceFolder}/target/classes"
  ],
  "console": "integratedTerminal",
  "bytehot": {
    "enabled": true,
    "autoDetect": true
  }
}
#+END_SRC

**** Status Bar Integration
- *Live indicator* showing ByteHot status (üî• Active, ‚è∏Ô∏è Paused, ‚ùå Stopped)
- *Hot-swap counter* displaying successful operations
- *Click actions* for quick start/stop control
- *Tooltip information* showing current configuration

**** Terminal Integration
- *Integrated terminal* for ByteHot agent output
- *Command execution* within VS Code environment
- *Log filtering* and highlighting for ByteHot events
- *Error navigation* jumping to problematic files

*** Key Features
- *Cross-platform support* (Windows, macOS, Linux)
- *Java Extension Pack integration* leveraging existing Java tooling
- *Workspace-scoped configuration* with team sharing capabilities
- *Remote development support* for GitHub Codespaces and SSH
- *Multi-root workspace support* for complex project structures

** Plugin Comparison and Selection Guide

| Feature | Maven Plugin | Gradle Plugin | IntelliJ Plugin | Eclipse Plugin | VS Code Extension |
|---------|--------------|---------------|------------------|----------------|-------------------|
| *Zero Config* | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| *Main Class Detection* | Auto (90%+) | Auto | Auto | Auto | Auto |
| *Build Integration* | Native | Native | IDE-based | Native | Language Server |
| *Visual Feedback* | Console | Console | Rich UI | Rich UI | Status Bar |
| *Debug Integration* | Limited | Limited | Full | Full | Partial |
| *Team Sharing* | =pom.xml= | =build.gradle= | =.idea/= | =.project= | =.vscode/= |
| *Platform Support* | All | All | All | All | All |
| *Learning Curve* | Low | Low | Minimal | Low | Minimal |

*** Selection Recommendations

**** Choose Maven Plugin if:
- Your project uses Maven as the primary build tool
- You prefer command-line driven development
- You want zero-configuration setup with minimal dependencies
- You're working in a CI/CD environment or containerized development

**** Choose Gradle Plugin if:
- Your project uses Gradle as the primary build tool
- You want advanced build lifecycle integration
- You need flexible property override capabilities
- You're working with Kotlin or Android projects

**** Choose IntelliJ IDEA Plugin if:
- IntelliJ IDEA is your primary development environment
- You want the richest visual feedback and integration
- You frequently use IntelliJ's debugging and profiling tools
- You're working on complex enterprise applications

**** Choose Eclipse Plugin if:
- Eclipse is your primary development environment
- You're working in enterprise environments with Eclipse standards
- You need integration with Eclipse's extensive plugin ecosystem
- You're maintaining legacy projects with Eclipse-based tooling

**** Choose VS Code Extension if:
- VS Code is your primary editor
- You're working on microservices or cloud-native applications
- You need cross-platform consistency
- You're working with polyglot projects (Java + JavaScript/Python/etc.)

** Manual Setup (Advanced Users and Custom Environments)

For specialized environments, containerized development, or when plugins aren't available:

*** Direct JVM Agent Approach
#+BEGIN_SRC bash
# Most flexible approach with explicit control
java -javaagent:bytehot-application-latest-SNAPSHOT-agent.jar \
     -Dbytehot.watch.paths=target/classes \
     -Dbytehot.user.id=$(git config user.email) \
     -Dbytehot.session.id=custom-dev-session \
     -Dbytehot.logging.level=DEBUG \
     -cp target/classes:dependency1.jar:dependency2.jar \
     com.example.Application
#+END_SRC

*** Docker Development Environment
#+BEGIN_SRC dockerfile
# Dockerfile for ByteHot-enabled development
FROM openjdk:17-jdk-slim

# Copy ByteHot agent
COPY bytehot-agent.jar /opt/bytehot/

# Set up development environment
WORKDIR /app
VOLUME ["/app/src", "/app/target"]

# Default command with ByteHot
ENTRYPOINT ["java", "-javaagent:/opt/bytehot/bytehot-agent.jar", \
            "-Dbytehot.watch.paths=/app/target/classes", \
            "-cp", "/app/target/classes"]
#+END_SRC

*** Kubernetes Development Pod
#+BEGIN_SRC yaml
apiVersion: v1
kind: Pod
metadata:
  name: bytehot-dev
spec:
  containers:
  - name: java-app
    image: openjdk:17-jdk
    command: [
      "java",
      "-javaagent:/opt/bytehot/bytehot-agent.jar",
      "-Dbytehot.watch.paths=/app/classes",
      "-cp", "/app/classes",
      "com.example.Application"
    ]
    volumeMounts:
    - name: source-code
      mountPath: /app
    - name: bytehot-agent
      mountPath: /opt/bytehot
  volumes:
  - name: source-code
    hostPath:
      path: /path/to/your/project
  - name: bytehot-agent
    configMap:
      name: bytehot-config
#+END_SRC

See the comprehensive plugin guides for detailed setup instructions:
- [[file:docs/user-guides/plugins/maven-plugin-guide.org][Maven Plugin Guide]] ‚úÖ Complete
- [[file:docs/user-guides/plugins/gradle-plugin-guide.org][Gradle Plugin Guide]] ‚úÖ Complete  
- [[file:docs/user-guides/plugins/intellij-plugin-guide.org][IntelliJ IDEA Plugin Guide]] ‚úÖ Complete
- [[file:docs/user-guides/plugins/eclipse-plugin-guide.org][Eclipse Plugin Guide]] üöß In Development
- [[file:docs/user-guides/plugins/vscode-extension-guide.org][VS Code Extension Guide]] üöß In Development
- [[file:docs/user-guides/plugins/containerized-development-guide.org][Containerized Development Guide]] üìã Planned

* Configuration
:PROPERTIES:
:CUSTOM_ID: configuration
:END:

ByteHot supports multiple configuration approaches with a clear priority order.

** Configuration Methods

ByteHot loads configuration in this priority order:
1. *System Properties* (~-Dbytehot.*~)
2. *Environment Variables* (~BYTEHOT_*~)
3. *External YAML file* (~-Dbhconfig=path/to/file.yml~)
4. *Classpath YAML files* (~bytehot.yml~, ~application.yml~)
5. *Default configuration*

** System Properties

| Property | Description | Default | Example |
|----------|-------------|---------|---------|
| =bytehot.watch.paths= | Directories to watch for changes | =target/classes= | =target/classes,build/classes= |
| =bytehot.watch.patterns= | File patterns to monitor | =*.class= | =**/*.class,**/*.jar= |
| =bhconfig= | Path to external YAML configuration file | None | =/path/to/bytehot.yml= |
| =bytehot.user.id= | Explicit user identification | Auto-detected | =john.doe@company.com= |
| =bytehot.session.id= | Session identifier | Auto-generated | =dev-session-123= |
| =bytehot.logging.level= | Logging verbosity | =INFO= | =DEBUG= |
| =bytehot.validation.strict= | Strict bytecode validation | =true= | =false= |

** Environment Variables

#+BEGIN_SRC bash
export BYTEHOT_WATCH_PATHS="target/classes,build/classes"
export BYTEHOT_WATCH_PATTERNS="**/*.class"
export BYTEHOT_USER_ID="developer@company.com"
export BYTEHOT_LOGGING_LEVEL="DEBUG"
#+END_SRC

** YAML Configuration

Create a ~bytehot.yml~ file and use ~-Dbhconfig~ to specify its location:

#+BEGIN_SRC yaml
bytehot:
  watch:
    - path: "target/classes"
      patterns: ["*.class"]
      recursive: true
    - path: "build/classes"
      patterns: ["*.class", "*.jar"]
      recursive: true
#+END_SRC

Use it with:
#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar -Dbhconfig=/path/to/bytehot.yml ...
#+END_SRC

** Configuration Examples

*** Spring Boot Application

#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar \
     -Dbytehot.watch.paths=target/classes \
     -Dbytehot.user.id=$(git config user.email) \
     -jar target/my-spring-app.jar
#+END_SRC

*** Multi-module Maven Project

#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar \
     -Dbytehot.watch.paths=module1/target/classes,module2/target/classes \
     -Dbytehot.watch.patterns=**/*.class \
     -cp "module1/target/classes:module2/target/classes" \
     com.example.MainApplication
#+END_SRC

*** Gradle Project

#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar \
     -Dbytehot.watch.paths=build/classes/java/main \
     -Dbytehot.watch.patterns=**/*.class \
     -cp build/classes/java/main \
     com.example.Application
#+END_SRC

*** Using Sample Configuration Files

ByteHot includes sample configuration files you can copy:

#+BEGIN_SRC bash
# Copy sample configuration
cp src/main/resources/examples/bytehot.yml ./my-bytehot-config.yml

# Use it
java -javaagent:bytehot-agent.jar \
     -Dbhconfig=./my-bytehot-config.yml \
     -cp target/classes \
     com.example.Application
#+END_SRC

* Basic Usage
:PROPERTIES:
:CUSTOM_ID: basic-usage
:END:

** File System Monitoring

ByteHot automatically monitors specified directories for =.class= file changes:

#+BEGIN_SRC bash
# Monitor single directory
-Dbytehot.watch.paths=target/classes

# Monitor multiple directories
-Dbytehot.watch.paths=target/classes,target/test-classes

# Custom patterns
-Dbytehot.watch.patterns=**/*.class,**/service/**/*.class
#+END_SRC

** User Identification

ByteHot automatically identifies users through multiple sources:

1. *Explicit configuration*: =-Dbytehot.user.id=john.doe@company.com=
2. *Git configuration*: Uses =git config user.email=
3. *System user*: Falls back to system username + hostname
4. *Anonymous*: Generates anonymous identifier if needed

** Session Management

ByteHot creates user sessions to track development activities:

#+BEGIN_SRC bash
# Explicit session ID
-Dbytehot.session.id=feature-development-session

# Auto-generated session (default)
# Sessions include: user, timestamp, environment info
#+END_SRC

** Hot-swap Lifecycle

Understanding the hot-swap process helps you work effectively with ByteHot:

1. *File Change Detection*: ByteHot detects =.class= file modifications
2. *Bytecode Analysis*: Validates the changes are hot-swap compatible
3. *Class Redefinition*: Uses JVM instrumentation to update the class
4. *Instance Updates*: Updates existing object instances with new behavior
5. *Event Recording*: Records the entire operation as events for audit trails

** Compatible Changes

ByteHot supports these types of changes:

‚úÖ *Supported Changes*:
- Method body modifications
- Adding new methods
- Adding new fields (with caution)
- Changing method implementations
- Adding static methods
- Modifying static initializers

‚ùå *Unsupported Changes*:
- Changing method signatures
- Removing methods
- Changing class hierarchy
- Modifying constructor signatures
- Adding/removing interfaces

* Advanced Features
:PROPERTIES:
:CUSTOM_ID: advanced-features
:END:

** Event-Driven Testing

ByteHot includes a revolutionary testing framework that uses events:

#+BEGIN_SRC java
@Test
void shouldUpdateInstancesAfterHotSwap() {
    // Given: System state from real events
    given()
        .event(new ByteHotAgentAttached("agent-123"))
        .event(new ClassFileChanged("/path/MyClass.class"));
    
    // When: The event we want to test
    when()
        .event(new InstanceUpdateRequested("MyClass", 2));
    
    // Then: Expected resulting events
    then()
        .expectEvent(InstancesUpdated.class)
        .withUpdatedCount(2)
        .withSuccessful(true);
}
#+END_SRC

** Flow Detection

ByteHot automatically discovers your development patterns:

#+BEGIN_SRC bash
# Enable flow detection
-Dbytehot.flow.detection.enabled=true

# Configure pattern analysis
-Dbytehot.flow.analysis.window=PT30M  # 30 minutes
-Dbytehot.flow.confidence.threshold=0.8
#+END_SRC

** User Analytics

Track your development productivity:

#+BEGIN_SRC java
// ByteHot automatically tracks:
// - Hot-swap success rates
// - Time saved by avoiding restarts  
// - Most frequently modified classes
// - Development patterns and workflows
#+END_SRC

** Bug Reporting with Event Context

When errors occur, ByteHot captures complete context:

#+BEGIN_SRC java
try {
    // Your code
} catch (Exception e) {
    // ByteHot automatically captures:
    // - Complete event history leading to the error
    // - User context and session information
    // - System state snapshot
    // - Reproducible test case generation
}
#+END_SRC

* Troubleshooting
:PROPERTIES:
:CUSTOM_ID: troubleshooting
:END:

** Common Issues

*** 1. Agent Not Attaching

*Problem*: ByteHot agent doesn't seem to be working

*Solutions*:
#+BEGIN_SRC bash
# Verify agent path is correct
ls -la path/to/bytehot-agent.jar

# Check Java version
java -version  # Should be 17+

# Enable debug logging
-Dbytehot.logging.level=DEBUG
#+END_SRC

*** 2. Classes Not Hot-swapping

*Problem*: Changes aren't being applied

*Solutions*:
#+BEGIN_SRC bash
# Verify watch paths are correct
-Dbytehot.watch.paths=target/classes  # Check this matches your build output

# Check file permissions
ls -la target/classes/com/example/

# Verify bytecode compatibility
# Make sure you're only changing method bodies, not signatures
#+END_SRC

*** 3. File System Events Not Detected

*Problem*: File changes aren't being detected

*Solutions*:
#+BEGIN_SRC bash
# Check if patterns match your files
-Dbytehot.watch.patterns=**/*.class

# Verify directory exists and is writable
test -d target/classes && test -w target/classes

# Check for filesystem-specific issues (Docker, network drives)
# Use absolute paths if needed
-Dbytehot.watch.paths=/absolute/path/to/classes
#+END_SRC

*** 4. Hot-swap Rejected

*Problem*: ByteHot rejects your changes

*Diagnosis*:
- Check logs for validation errors
- Ensure you're only modifying method bodies
- Avoid changing method signatures or class structure

*Solutions*:
#+BEGIN_SRC java
// Good: Changing method implementation
public void process() {
    // New implementation
    logger.info("Updated processing logic");
}

// Bad: Changing method signature
// public void process(String param) { ... }  // Don't do this
#+END_SRC

*** 5. Configuration Not Loading

*Problem*: ByteHot seems to ignore your configuration

*Solutions*:
#+BEGIN_SRC bash
# Verify system properties syntax
java -Dbytehot.watch.paths=target/classes ...  # Correct
java -D bytehot.watch.paths=target/classes ... # Wrong (space after -D)

# Check YAML file path is absolute or relative to working directory
-Dbhconfig=/absolute/path/to/bytehot.yml        # Absolute path
-Dbhconfig=./relative/path/to/bytehot.yml       # Relative path

# Verify YAML syntax is correct
# Use a YAML validator or copy from examples/
cp src/main/resources/examples/bytehot-simple.yml ./test.yml

# Test with minimal configuration first
-Dbytehot.watch.paths=target/classes  # Start simple
#+END_SRC

*Diagnosis*:
#+BEGIN_SRC bash
# Check if directories exist
ls -la target/classes

# Verify JAR path is correct
ls -la target/bytehot-*-shaded.jar

# Test with absolute paths
-Dbytehot.watch.paths=/full/path/to/target/classes
#+END_SRC

** Debug Mode

Enable comprehensive debugging:

#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar \
     -Dbytehot.logging.level=DEBUG \
     -Dbytehot.validation.verbose=true \
     -Dbytehot.events.trace=true \
     -cp target/classes \
     com.example.Application
#+END_SRC

** Log Analysis

ByteHot provides detailed logs:

#+BEGIN_EXAMPLE
[ByteHot] Agent attached successfully
[ByteHot] Watching: target/classes
[ByteHot] User identified: john.doe@company.com
[ByteHot] Session started: session-abc123
[ByteHot] File change detected: target/classes/com/example/Service.class
[ByteHot] Bytecode validation: PASSED
[ByteHot] Hot-swap executed successfully
[ByteHot] Instances updated: 3 objects
#+END_EXAMPLE

* Best Practices
:PROPERTIES:
:CUSTOM_ID: best-practices
:END:

** 1. Development Workflow Optimization

*** Environment Setup for Teams
#+BEGIN_SRC bash
# Team-wide development setup script
#!/bin/bash
# scripts/setup-bytehot-dev.sh

# Detect build tool and set appropriate defaults
if [ -f "pom.xml" ]; then
    export BYTEHOT_CLASSES="target/classes"
    export BYTEHOT_TEST_CLASSES="target/test-classes"
    BUILD_TOOL="maven"
elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
    export BYTEHOT_CLASSES="build/classes/java/main"
    export BYTEHOT_TEST_CLASSES="build/classes/java/test"
    BUILD_TOOL="gradle"
else
    export BYTEHOT_CLASSES="bin"
    export BYTEHOT_TEST_CLASSES="bin"
    BUILD_TOOL="manual"
fi

# Set ByteHot agent path (customize for your team)
export BYTEHOT_AGENT="$HOME/.m2/repository/org/acmsl/bytehot-application/latest-SNAPSHOT/bytehot-application-latest-SNAPSHOT-agent.jar"

# Create development aliases
alias bh-dev="java -javaagent:$BYTEHOT_AGENT -Dbytehot.watch.paths=$BYTEHOT_CLASSES"
alias bh-test="java -javaagent:$BYTEHOT_AGENT -Dbytehot.watch.paths=$BYTEHOT_CLASSES,$BYTEHOT_TEST_CLASSES"
alias bh-debug="java -javaagent:$BYTEHOT_AGENT -Dbytehot.watch.paths=$BYTEHOT_CLASSES -Dbytehot.logging.level=DEBUG"

echo "ByteHot development environment configured for $BUILD_TOOL project"
echo "Available commands: bh-dev, bh-test, bh-debug"
#+END_SRC

*** Plugin-Based Best Practices

**** Maven Plugin Workflow
#+BEGIN_SRC bash
# Optimal Maven development workflow

# Start development session
mvn bytehot:live -Dbytehot.verbose=true

# In another terminal, make changes and compile
mvn compile  # Changes are automatically hot-swapped

# For test-driven development
mvn bytehot:live -Dbytehot.watch.paths=target/classes,target/test-classes
#+END_SRC

**** Gradle Plugin Workflow
#+BEGIN_SRC bash
# Optimal Gradle development workflow

# Start with automatic compilation
./gradlew live --continuous

# Or with manual compilation control
./gradlew live &
./gradlew compileJava  # Triggers hot-swap
#+END_SRC

**** IntelliJ IDEA Integration Best Practices
1. *Enable Build Project Automatically*:
   - =Settings ‚Üí Build, Execution, Deployment ‚Üí Compiler=
   - Check "Build project automatically"
   - Check "Compile independent modules in parallel"

2. *Configure Run Configuration Template*:
   - =Run ‚Üí Edit Configurations ‚Üí Templates ‚Üí Application=
   - Add VM options: =-javaagent:path/to/bytehot-agent.jar=
   - Add environment variable: =BYTEHOT_WATCH_PATHS=target/classes=

3. *Setup Shared Team Configuration*:
   - Create =.idea/runConfigurations/ByteHot_Development.xml=
   - Commit to version control for team sharing
   - Use path variables for cross-platform compatibility

** 2. IDE-Specific Integration Strategies

*** IntelliJ IDEA Advanced Integration

**** Shared Run Configuration
#+BEGIN_SRC xml
<!-- .idea/runConfigurations/ByteHot_Development.xml -->
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="ByteHot Development" type="Application">
    <option name="MAIN_CLASS_NAME" value="com.example.Application" />
    <option name="VM_PARAMETERS" value="-javaagent:$USER_HOME$/.m2/repository/org/acmsl/bytehot-application/latest-SNAPSHOT/bytehot-application-latest-SNAPSHOT-agent.jar -Dbytehot.watch.paths=$PROJECT_DIR$/target/classes -Dbytehot.user.id=$USER$@$HOST$" />
    <option name="PROGRAM_PARAMETERS" value="" />
    <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
    <module name="your-module-name" />
    <method v="2">
      <option name="Make" enabled="true" />
    </method>
  </configuration>
</component>
#+END_SRC

**** Live Templates for ByteHot Testing
#+BEGIN_SRC java
// Live Template: bht (ByteHot Test)
@Test
void should$DESCRIPTION$() {
    given()
        .event(new $SETUP_EVENT$($SETUP_PARAMS$));
    
    when()
        .event(new $TEST_EVENT$($TEST_PARAMS$));
    
    then()
        .expectEvent($EXPECTED_EVENT$.class)
        .$VERIFICATION_METHOD$($EXPECTED_VALUE$);
}
#+END_SRC

*** Eclipse Advanced Integration

**** Project-Level Configuration
#+BEGIN_SRC xml
<!-- .project -->
<projectDescription>
  <name>your-project</name>
  <buildSpec>
    <buildCommand>
      <name>org.eclipse.jdt.core.javabuilder</name>
    </buildCommand>
    <buildCommand>
      <name>org.acmsl.bytehot.eclipse.builder</name>
      <arguments>
        <dictionary>
          <key>watchPaths</key>
          <value>bin,target/classes</value>
        </dictionary>
        <dictionary>
          <key>autoStart</key>
          <value>true</value>
        </dictionary>
      </arguments>
    </buildCommand>
  </buildSpec>
  <natures>
    <nature>org.eclipse.jdt.core.javanature</nature>
    <nature>org.acmsl.bytehot.eclipse.nature</nature>
  </natures>
</projectDescription>
#+END_SRC

**** Launch Configuration Template
#+BEGIN_SRC xml
<!-- .metadata/.plugins/org.eclipse.debug.core/.launches/ByteHot Development.launch -->
<launchConfiguration type="org.eclipse.jdt.launching.localJavaApplication">
  <stringAttribute key="org.eclipse.jdt.launching.MAIN_TYPE" value="com.example.Application"/>
  <stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value="your-project"/>
  <stringAttribute key="org.eclipse.jdt.launching.VM_ARGUMENTS" value="-javaagent:${workspace_loc}/.bytehot/bytehot-agent.jar -Dbytehot.watch.paths=${workspace_loc}/bin"/>
  <booleanAttribute key="org.eclipse.jdt.launching.ATTR_USE_CLASSPATH_ONLY_JAR" value="false"/>
</launchConfiguration>
#+END_SRC

*** VS Code Advanced Integration

**** Workspace Configuration
#+BEGIN_SRC json
// .vscode/settings.json
{
  "java.configuration.updateBuildConfiguration": "automatic",
  "java.compile.nullAnalysis.mode": "automatic",
  "bytehot.enabled": true,
  "bytehot.autoStart": true,
  "bytehot.agent.path": "${workspaceFolder}/.vscode/bytehot-agent.jar",
  "bytehot.watch.paths": [
    "${workspaceFolder}/target/classes",
    "${workspaceFolder}/build/classes/java/main"
  ],
  "bytehot.user.detection.sources": ["git", "environment", "prompt"],
  "bytehot.logging.level": "INFO",
  "bytehot.validation.strict": true
}
#+END_SRC

**** Task Integration
#+BEGIN_SRC json
// .vscode/tasks.json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "ByteHot: Start Live Mode",
      "type": "shell",
      "command": "java",
      "args": [
        "-javaagent:${workspaceFolder}/.vscode/bytehot-agent.jar",
        "-Dbytehot.watch.paths=${workspaceFolder}/target/classes",
        "-cp", "${workspaceFolder}/target/classes",
        "${input:mainClass}"
      ],
      "group": "build",
      "presentation": {
        "echo": true,
        "reveal": "always",
        "focus": false,
        "panel": "new",
        "showReuseMessage": true,
        "clear": false
      },
      "problemMatcher": {
        "pattern": {
          "regexp": "^\\[ByteHot\\]\\s+(ERROR|WARN):\\s+(.*)$",
          "severity": 1,
          "message": 2
        }
      }
    }
  ],
  "inputs": [
    {
      "id": "mainClass",
      "description": "Main class to run",
      "default": "com.example.Application",
      "type": "promptString"
    }
  ]
}
#+END_SRC


** 3. Team Development and Collaboration

*** Shared Team Configuration

**** Project-Level Configuration Management
#+BEGIN_SRC yaml
# bytehot-team.yml - Commit to version control
bytehot:
  team:
    # Shared watch paths that work across different build tools
    watch:
      maven:
        - path: "target/classes"
          patterns: ["**/*.class"]
        - path: "target/test-classes"
          patterns: ["**/*.class"]
      gradle:
        - path: "build/classes/java/main"
          patterns: ["**/*.class"] 
        - path: "build/classes/java/test"
          patterns: ["**/*.class"]
    
    # Development profiles for different scenarios
    profiles:
      development:
        logging.level: "INFO"
        validation.strict: true
        user.analytics.enabled: true
      
      debugging:
        logging.level: "DEBUG"
        events.trace: true
        performance.monitoring: true
      
      testing:
        watch.patterns: ["**/*Test.class", "**/*IT.class"]
        session.timeout: "PT10M"
#+END_SRC

**** Cross-Platform Development Script
#+BEGIN_SRC bash
#!/bin/bash
# scripts/bytehot-dev.sh - Works on Linux, macOS, Windows (Git Bash)

set -euo pipefail

# Detect operating system and set defaults
case "$(uname -s)" in
    Linux*)     PLATFORM=linux;;
    Darwin*)    PLATFORM=macos;;
    CYGWIN*|MINGW*|MSYS*) PLATFORM=windows;;
    *)          PLATFORM=unknown;;
esac

# Detect build tool and set classpath
if [ -f "pom.xml" ]; then
    CLASSES_PATH="target/classes"
    TEST_CLASSES_PATH="target/test-classes"
    BUILD_TOOL="maven"
    echo "Detected Maven project"
elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
    CLASSES_PATH="build/classes/java/main"
    TEST_CLASSES_PATH="build/classes/java/test"
    BUILD_TOOL="gradle"
    echo "Detected Gradle project"
else
    echo "Warning: No build tool detected, using default paths"
    CLASSES_PATH="bin"
    TEST_CLASSES_PATH="test-bin"
    BUILD_TOOL="manual"
fi

# Find ByteHot agent JAR
BYTEHOT_AGENT=""
for location in \
    "$HOME/.m2/repository/org/acmsl/bytehot-application/latest-SNAPSHOT/bytehot-application-latest-SNAPSHOT-agent.jar" \
    "./tools/bytehot-agent.jar" \
    "./lib/bytehot-agent.jar" \
    "./bytehot-agent.jar"; do
    if [ -f "$location" ]; then
        BYTEHOT_AGENT="$location"
        echo "Found ByteHot agent at: $location"
        break
    fi
done

if [ -z "$BYTEHOT_AGENT" ]; then
    echo "Error: ByteHot agent JAR not found. Please install or download it."
    echo "Tried locations:"
    echo "  - ~/.m2/repository/org/acmsl/bytehot-application/latest-SNAPSHOT/"
    echo "  - ./tools/bytehot-agent.jar"
    echo "  - ./lib/bytehot-agent.jar"
    echo "  - ./bytehot-agent.jar"
    exit 1
fi

# Get user identification
USER_ID="${BYTEHOT_USER_ID:-$(git config user.email 2>/dev/null || echo "${USER}@${HOSTNAME}")}"

# Get main class (try multiple detection methods)
MAIN_CLASS=""
if [ "$BUILD_TOOL" = "maven" ] && [ -f "pom.xml" ]; then
    # Try to extract main class from Maven configuration
    MAIN_CLASS=$(grep -E "<mainClass>" pom.xml | sed 's/.*<mainClass>\(.*\)<\/mainClass>.*/\1/' | head -1 || echo "")
elif [ "$BUILD_TOOL" = "gradle" ]; then
    # Try to extract main class from Gradle configuration
    MAIN_CLASS=$(grep -E "mainClass\s*=" build.gradle* | sed "s/.*mainClass\s*=\s*['\"]\([^'\"]*\)['\"].*/\1/" | head -1 || echo "")
fi

# Fallback: ask user or use provided argument
if [ -z "$MAIN_CLASS" ]; then
    if [ $# -gt 0 ]; then
        MAIN_CLASS="$1"
    else
        echo "Main class not detected. Please specify:"
        read -p "Main class: " MAIN_CLASS
    fi
fi

echo "Starting ByteHot with:"
echo "  Platform: $PLATFORM"
echo "  Build Tool: $BUILD_TOOL"
echo "  Agent: $BYTEHOT_AGENT"
echo "  Classes: $CLASSES_PATH"
echo "  Main Class: $MAIN_CLASS"
echo "  User: $USER_ID"
echo ""

# Build classpath
CLASSPATH="$CLASSES_PATH"
if [ -d "$TEST_CLASSES_PATH" ]; then
    CLASSPATH="$CLASSPATH:$TEST_CLASSES_PATH"
fi

# Add dependencies to classpath based on build tool
if [ "$BUILD_TOOL" = "maven" ]; then
    # Add Maven dependencies if available
    if command -v mvn >/dev/null; then
        DEPS=$(mvn dependency:build-classpath -Dmdep.outputFile=/dev/stdout -q 2>/dev/null || echo "")
        if [ -n "$DEPS" ]; then
            CLASSPATH="$CLASSPATH:$DEPS"
        fi
    fi
elif [ "$BUILD_TOOL" = "gradle" ]; then
    # Add Gradle dependencies if available
    if command -v gradle >/dev/null || [ -f "./gradlew" ]; then
        GRADLE_CMD="gradle"
        [ -f "./gradlew" ] && GRADLE_CMD="./gradlew"
        DEPS=$($GRADLE_CMD printClasspath -q 2>/dev/null || echo "")
        if [ -n "$DEPS" ]; then
            CLASSPATH="$CLASSPATH:$DEPS"
        fi
    fi
fi

# Launch with ByteHot
exec java \
    -javaagent:"$BYTEHOT_AGENT" \
    -Dbytehot.watch.paths="$CLASSES_PATH" \
    -Dbytehot.user.id="$USER_ID" \
    -Dbytehot.session.id="dev-$(date +%Y%m%d%H%M%S)" \
    -Dbytehot.logging.level="${BYTEHOT_LOG_LEVEL:-INFO}" \
    -cp "$CLASSPATH" \
    "$MAIN_CLASS" \
    "$@"
#+END_SRC

*** Team Synchronization Strategies

**** Version Control Integration
#+BEGIN_SRC bash
# .gitignore entries for ByteHot
# Include team configuration
!bytehot-team.yml
!scripts/bytehot-dev.sh
!.vscode/settings.json
!.idea/runConfigurations/ByteHot*.xml

# Exclude individual settings
.bytehot/sessions/
.bytehot/cache/
bytehot-local.yml
#+END_SRC

**** Onboarding Documentation
#+BEGIN_SRC markdown
<!-- docs/BYTEHOT_SETUP.md - Team onboarding guide -->
# ByteHot Setup for New Team Members

## Quick Start (< 5 minutes)
1. Clone the repository
2. Run `./scripts/bytehot-dev.sh` (Unix) or `scripts\bytehot-dev.bat` (Windows)
3. The script will auto-detect your environment and guide you through any missing setup

## IDE Integration
- **IntelliJ IDEA**: Import run configuration from `.idea/runConfigurations/`
- **Eclipse**: Import project, ByteHot nature will be auto-configured
- **VS Code**: Open workspace, extensions will prompt for ByteHot setup

## Troubleshooting
- Check `docs/TROUBLESHOOTING.md` for common issues
- Run `./scripts/bytehot-dev.sh --check` to validate your setup
- Ask in #dev-tools Slack channel for team-specific help
#+END_SRC

** 4. Testing Strategy

#+BEGIN_SRC java
// Use ByteHot's event-driven testing for better tests
public class MyServiceTest extends EventDrivenTestSupport {
    
    @Test
    void shouldHandleUserRequest() {
        given()
            .event(new UserRegistered(userId))
            .event(new ServiceInitialized());
        
        when()
            .event(new ProcessUserRequest(userId, request));
        
        then()
            .expectEvent(RequestProcessed.class)
            .withUserId(userId)
            .withSuccessful(true);
    }
}
#+END_SRC

** 5. Production Considerations

*‚ö†Ô∏è Important*: ByteHot is designed for development environments.

For production:
- *Never* use ByteHot in production environments
- Use proper deployment processes for production changes
- Consider using ByteHot for *staging/testing* environments only

** 6. Performance Tips

#+BEGIN_SRC bash
# Optimize file watching for large projects
-Dbytehot.watch.patterns=**/service/**/*.class,**/controller/**/*.class

# Exclude test classes from watching
-Dbytehot.watch.patterns=**/*.class,!**/*Test.class

# Tune validation settings
-Dbytehot.validation.timeout=5000  # 5 seconds
-Dbytehot.hotswap.retries=3
#+END_SRC

* Examples
:PROPERTIES:
:CUSTOM_ID: examples
:END:

** Example 1: Spring Boot REST API

#+BEGIN_SRC java
// src/main/java/com/example/UserController.java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        // Initial implementation
        return ResponseEntity.ok(userService.findById(id));
    }
}
#+END_SRC

*Run with ByteHot*:
#+BEGIN_SRC bash
java -javaagent:bytehot-agent.jar \
     -Dbytehot.watch.paths=target/classes \
     -jar target/my-spring-app.jar
#+END_SRC

*Hot-swap the endpoint*:
#+BEGIN_SRC java
@GetMapping("/{id}")
public ResponseEntity<User> getUser(@PathVariable Long id) {
    // Enhanced implementation with caching
    User user = cacheService.get(id);
    if (user == null) {
        user = userService.findById(id);
        cacheService.put(id, user);
    }
    return ResponseEntity.ok(user);
}
#+END_SRC

Recompile and watch your running API immediately use the new caching logic!

** Example 2: Background Service

#+BEGIN_SRC java
// com/example/DataProcessor.java
@Component
public class DataProcessor {
    
    @Scheduled(fixedRate = 5000)
    public void processData() {
        // Original processing logic
        List<Data> data = dataRepository.findUnprocessed();
        data.forEach(this::processItem);
    }
    
    private void processItem(Data item) {
        // Simple processing
        item.setStatus("PROCESSED");
        dataRepository.save(item);
    }
}
#+END_SRC

*Hot-swap to add error handling*:
#+BEGIN_SRC java
private void processItem(Data item) {
    try {
        // Enhanced processing with validation
        if (item.isValid()) {
            item.setStatus("PROCESSED");
            item.setProcessedAt(Instant.now());
        } else {
            item.setStatus("VALIDATION_FAILED");
            item.setErrorMessage("Invalid data format");
        }
        dataRepository.save(item);
    } catch (Exception e) {
        logger.error("Processing failed for item {}", item.getId(), e);
        item.setStatus("ERROR");
        item.setErrorMessage(e.getMessage());
        dataRepository.save(item);
    }
}
#+END_SRC

** Example 3: Event-Driven Testing

#+BEGIN_SRC java
public class HotSwapIntegrationTest extends EventDrivenTestSupport {
    
    @Test
    void shouldCompleteFullHotSwapFlow() {
        // Given: ByteHot is running and monitoring files
        given()
            .event(new ByteHotAgentAttached("test-agent"))
            .event(new WatchPathConfigured("target/test-classes", "**/*.class"))
            .event(new UserSessionStarted(UserId.of("test-user")));
        
        // When: A class file is modified
        when()
            .event(new ClassFileChanged("target/test-classes/TestService.class", "TestService", 2048));
        
        // Then: Complete hot-swap flow should execute
        then()
            .expectSequence()
                .then(ClassMetadataExtracted.class)
                .then(BytecodeValidated.class)
                .then(HotSwapRequested.class)
                .then(ClassRedefinitionSucceeded.class)
                .then(InstancesUpdated.class)
            .inOrder()
            .expectEvent(UserStatisticsUpdated.class)
                .withSuccessfulHotSwaps(1);
    }
}
#+END_SRC

* Next Steps

Now that you're familiar with ByteHot basics:

1. *Try the Quick Start* example with your own application
2. *Explore Advanced Features* like flow detection and user analytics
3. *Integrate with your IDE* for seamless development
4. *Read the Architecture Documentation* to understand ByteHot's design
5. *Join the Community* and contribute to ByteHot's development

** Additional Resources

- üìö *[[docs/architecture.html][Architecture Guide]]*: Deep dive into ByteHot's design
- üîß *[[javadocs/][API Documentation]]*: Complete API reference
- üéØ *[[examples/][Examples Repository]]*: More comprehensive examples
- üêõ *[[https://github.com/rydnr/bytehot/issues][Issue Tracker]]*: Report bugs or request features
- üí¨ *[[https://github.com/rydnr/bytehot/discussions][Discussions]]*: Community support and ideas

** Contributing

ByteHot is open source and welcomes contributions:

#+BEGIN_SRC bash
# Fork the repository
git clone https://github.com/your-username/bytehot.git

# Create a feature branch
git checkout -b feature/amazing-feature

# Make your changes and test
mvn test

# Follow ByteHot's commit conventions
git commit -m "‚ú® Add amazing feature

Implement amazing new functionality that improves developer experience.

ü§ñ Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: YourName <your.email@domain.com>"

# Submit a pull request
#+END_SRC

Welcome to the ByteHot community! üî• Happy hot-swapping! üöÄ