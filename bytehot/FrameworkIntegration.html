<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FrameworkIntegration - ByteHot Documentation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 100%); color: #00ff00; line-height: 1.6; overflow-x: hidden; }
        .matrix-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; opacity: 0.05; }
        .nav-header { position: fixed; top: 0; left: 0; right: 0; background: rgba(15, 15, 35, 0.95); backdrop-filter: blur(10px); padding: 1rem 2rem; z-index: 1000; border-bottom: 2px solid #00ff00; }
        .nav-links { display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; }
        .nav-link { color: #00ff00; text-decoration: none; padding: 0.4rem 0.8rem; border: 1px solid #00ff00; border-radius: 4px; transition: all 0.3s ease; font-weight: bold; font-size: 0.9rem; }
        .nav-link:hover { background: #00ff00; color: #0f0f23; box-shadow: 0 0 15px #00ff00; transform: translateY(-2px); }
        .content { margin-top: 100px; padding: 2rem; max-width: 1200px; margin-left: auto; margin-right: auto; }
        .doc-container { background: rgba(26, 26, 58, 0.8); border: 1px solid #00ff00; border-radius: 12px; padding: 3rem; margin: 2rem 0; }
        .doc-container h1 { color: #00cccc; font-size: 2.5rem; margin: 0 0 2rem 0; text-shadow: 0 0 15px #00cccc; text-align: center; }
        .doc-container h2 { color: #00ff00; font-size: 1.8rem; margin: 2rem 0 1rem 0; border-left: 4px solid #00ff00; padding-left: 1rem; text-shadow: 0 0 10px #00ff00; }
        .doc-container h3 { color: #00cccc; font-size: 1.4rem; margin: 1.5rem 0 1rem 0; }
        .doc-container h4, .doc-container h5, .doc-container h6 { color: #ffffff; margin: 1rem 0 0.5rem 0; }
        .doc-container p { color: #ffffff; margin: 1rem 0; line-height: 1.8; }
        .doc-container ul, .doc-container ol { color: #ffffff; margin: 1rem 0; padding-left: 2rem; }
        .doc-container li { margin: 0.5rem 0; line-height: 1.6; }
        .doc-container code { background: rgba(0, 0, 0, 0.5); color: #00ff00; padding: 0.2rem 0.4rem; border-radius: 4px; font-family: 'Courier New', monospace; border: 1px solid rgba(0, 255, 0, 0.3); }
        .doc-container pre { background: rgba(0, 0, 0, 0.8); border: 1px solid #00ff00; border-radius: 8px; padding: 1.5rem; overflow-x: auto; margin: 1.5rem 0; }
        .doc-container pre code { background: none; padding: 0; border: none; }
        .doc-container a { color: #00cccc; text-decoration: none; border-bottom: 1px dotted #00cccc; transition: all 0.3s ease; }
        .doc-container a:hover { color: #ffffff; border-bottom-color: #ffffff; text-shadow: 0 0 5px #00cccc; }
        .doc-container table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; background: rgba(0, 0, 0, 0.3); }
        .doc-container th, .doc-container td { border: 1px solid #00ff00; padding: 0.8rem; text-align: left; }
        .doc-container th { background: rgba(0, 255, 0, 0.1); color: #00ff00; font-weight: bold; }
        .doc-container td { color: #ffffff; }
        .doc-container blockquote { border-left: 4px solid #00cccc; padding-left: 1.5rem; margin: 1.5rem 0; color: #00cccc; font-style: italic; background: rgba(0, 204, 204, 0.05); padding: 1rem 1rem 1rem 1.5rem; border-radius: 0 8px 8px 0; }
        .footer { background: rgba(0, 0, 0, 0.8); padding: 2rem; text-align: center; border-top: 2px solid #00ff00; margin-top: 4rem; }
        .footer a { color: #00ff00; text-decoration: none; }
        .footer a:hover { text-shadow: 0 0 10px #00ff00; }
        @media (max-width: 768px) { .nav-links { gap: 0.8rem; } .nav-link { padding: 0.3rem 0.6rem; font-size: 0.8rem; } .content { padding: 1rem; } .doc-container { padding: 2rem; } .doc-container h1 { font-size: 2rem; } }
    </style>
</head>
<body>
    <div class="matrix-bg"></div>
    
    <nav class="nav-header">
        <div class="nav-links">
            <a href="index.html" class="nav-link">Home</a>
            <a href="story.html" class="nav-link">üìñ Story</a>
            <a href="GETTING_STARTED.html" class="nav-link">üöÄ Getting Started</a>
            <a href="implementation.html" class="nav-link">‚öôÔ∏è Implementation</a>
            <a href="literate-docs.html" class="nav-link">üìö Literate Docs</a>
            <a href="journal.html" class="nav-link">üìî Journal</a>
            <a href="javadocs/" class="nav-link">JavaDocs</a>
            <a href="https://github.com/rydnr/bytehot" class="nav-link">GitHub</a>
        </div>
    </nav>

    <div class="content">
        <div class="doc-container">
<h1 id="overview">Overview</h1>
<p>The <code class="verbatim">FrameworkIntegration</code> class provides
specialized instance management capabilities for different dependency
injection and application frameworks. It enables ByteHot to work
seamlessly with Spring, CDI, Guice, and other frameworks by providing
framework-specific instance update strategies.</p>
<h2 id="key-responsibilities">Key Responsibilities</h2>
<ul>
<li>Detect and integrate with various application frameworks</li>
<li>Provide framework-specific instance update strategies</li>
<li>Handle framework-managed instances and proxies</li>
<li>Support dependency injection container integration</li>
<li>Enable framework-aware hot-swap operations</li>
</ul>
<h1 id="class-declaration-and-core-structure">Class Declaration and Core
Structure</h1>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/FrameworkIntegration.java"><code>/*
                        ByteHot

    Copyright (C) 2025-today  rydnr@acm-sl.org

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public v3
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Thanks to ACM S.L. for distributing this library under the GPLv3 license.
    Contact info: jose.sanleandro@acm-sl.com

 ******************************************************************************
 *
 * Filename: FrameworkIntegration.java
 *
 * Author: Claude Code
 *
 * Class name: FrameworkIntegration
 *
 * Responsibilities:
 *   - Detect and integrate with application frameworks
 *   - Provide framework-specific instance management strategies
 *   - Handle framework-managed instances and dependency injection
 *
 * Collaborators:
 *   - InstanceUpdater: Uses framework integration for updates
 *   - InstanceUpdateMethod: Provides framework-specific methods
 */
package org.acmsl.bytehot.domain;

import lombok.Getter;

import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Framework-specific instance management and integration
 * @author Claude Code
 * @since 2025-06-17
 */
@Getter
public class FrameworkIntegration {

    /**
     * Type of framework detected
     */
    private final FrameworkType frameworkType;

    /**
     * Whether the framework is available and detected
     */
    private final boolean available;

    /**
     * Version of the framework, if available
     */
    private final String frameworkVersion;

    /**
     * Framework-specific configuration and capabilities
     */
    private final Map&lt;String, Object&gt; frameworkCapabilities;

    /**
     * List of classes that are managed by the framework
     */
    private final List&lt;Class&lt;?&gt;&gt; managedClasses;

    /**
     * Creates a new framework integration
     */
    private FrameworkIntegration(final FrameworkType frameworkType, final boolean available,
                                final String frameworkVersion, final Map&lt;String, Object&gt; frameworkCapabilities) {
        this.frameworkType = frameworkType;
        this.available = available;
        this.frameworkVersion = frameworkVersion;
        this.frameworkCapabilities = new ConcurrentHashMap&lt;&gt;(frameworkCapabilities);
        this.managedClasses = new CopyOnWriteArrayList&lt;&gt;();
    }

    /**
     * Creates a framework integration for an available framework
     */
    public static FrameworkIntegration available(final FrameworkType frameworkType, final String frameworkVersion,
                                               final Map&lt;String, Object&gt; capabilities) {
        return new FrameworkIntegration(frameworkType, true, frameworkVersion, capabilities);
    }

    /**
     * Creates a framework integration for an unavailable framework
     */
    public static FrameworkIntegration unavailable(final FrameworkType frameworkType) {
        return new FrameworkIntegration(frameworkType, false, null, Map.of());
    }

    /**
     * Detects available frameworks in the current environment
     */
    public static List&lt;FrameworkIntegration&gt; detectFrameworks() {
        final List&lt;FrameworkIntegration&gt; integrations = new CopyOnWriteArrayList&lt;&gt;();

        // Detect Spring Framework
        if (isSpringAvailable()) {
            integrations.add(createSpringIntegration());
        }

        // Detect CDI
        if (isCdiAvailable()) {
            integrations.add(createCdiIntegration());
        }

        // Detect Guice
        if (isGuiceAvailable()) {
            integrations.add(createGuiceIntegration());
        }

        // Add unavailable frameworks for completeness
        for (final FrameworkType type : FrameworkType.values()) {
            if (integrations.stream().noneMatch(i -&gt; i.getFrameworkType() == type)) {
                integrations.add(FrameworkIntegration.unavailable(type));
            }
        }

        return integrations;
    }

    /**
     * Returns whether this framework can handle the given class
     */
    public boolean canHandle(final Class&lt;?&gt; clazz) {
        if (!available) {
            return false;
        }

        return switch (frameworkType) {
            case SPRING -&gt; hasSpringAnnotations(clazz);
            case CDI -&gt; hasCdiAnnotations(clazz);
            case GUICE -&gt; hasGuiceAnnotations(clazz);
            case PLAIN_JAVA -&gt; true; // Can always handle plain Java
        };
    }

    /**
     * Returns the recommended update method for this framework
     */
    public InstanceUpdateMethod getRecommendedUpdateMethod() {
        if (!available) {
            return InstanceUpdateMethod.REFLECTION;
        }

        return switch (frameworkType) {
            case SPRING -&gt; InstanceUpdateMethod.FACTORY_RESET;
            case CDI -&gt; InstanceUpdateMethod.PROXY_REFRESH;
            case GUICE -&gt; InstanceUpdateMethod.FACTORY_RESET;
            case PLAIN_JAVA -&gt; InstanceUpdateMethod.REFLECTION;
        };
    }

    /**
     * Updates instances using framework-specific mechanisms
     */
    public boolean updateInstances(final Class&lt;?&gt; clazz, final byte[] newBytecode) {
        if (!available || !canHandle(clazz)) {
            return false;
        }

        try {
            return switch (frameworkType) {
                case SPRING -&gt; updateSpringInstances(clazz, newBytecode);
                case CDI -&gt; updateCdiInstances(clazz, newBytecode);
                case GUICE -&gt; updateGuiceInstances(clazz, newBytecode);
                case PLAIN_JAVA -&gt; updatePlainJavaInstances(clazz, newBytecode);
            };
        } catch (final Exception e) {
            return false;
        }
    }

    /**
     * Returns whether the framework supports proxy refresh
     */
    public boolean supportsProxyRefresh() {
        return available &amp;&amp; (frameworkType == FrameworkType.SPRING || frameworkType == FrameworkType.CDI);
    }

    /**
     * Returns whether the framework supports factory reset
     */
    public boolean supportsFactoryReset() {
        return available &amp;&amp; (frameworkType == FrameworkType.SPRING || frameworkType == FrameworkType.GUICE);
    }

    /**
     * Returns whether the framework supports dependency injection
     */
    public boolean supportsDependencyInjection() {
        return available &amp;&amp; frameworkType != FrameworkType.PLAIN_JAVA;
    }

    /**
     * Gets a framework capability value
     */
    public Object getCapability(final String key) {
        return frameworkCapabilities.get(key);
    }

    /**
     * Checks if a framework capability exists
     */
    public boolean hasCapability(final String key) {
        return frameworkCapabilities.containsKey(key);
    }

    /**
     * Adds a class to the list of framework-managed classes
     */
    public void addManagedClass(final Class&lt;?&gt; clazz) {
        if (!managedClasses.contains(clazz)) {
            managedClasses.add(clazz);
        }
    }

    /**
     * Framework types supported by ByteHot
     */
    public enum FrameworkType {
        SPRING(&quot;Spring Framework&quot;),
        CDI(&quot;Contexts and Dependency Injection&quot;),
        GUICE(&quot;Google Guice&quot;),
        PLAIN_JAVA(&quot;Plain Java&quot;);

        private final String description;

        FrameworkType(final String description) {
            this.description = description;
        }

        public String getDescription() {
            return description;
        }
    }

    // Framework Detection Methods

    private static boolean isSpringAvailable() {
        try {
            Class.forName(&quot;org.springframework.context.ApplicationContext&quot;);
            return true;
        } catch (final ClassNotFoundException e) {
            return false;
        }
    }

    private static boolean isCdiAvailable() {
        try {
            Class.forName(&quot;javax.enterprise.context.ApplicationScoped&quot;);
            return true;
        } catch (final ClassNotFoundException e) {
            return false;
        }
    }

    private static boolean isGuiceAvailable() {
        try {
            Class.forName(&quot;com.google.inject.Injector&quot;);
            return true;
        } catch (final ClassNotFoundException e) {
            return false;
        }
    }

    // Framework Integration Creation

    private static FrameworkIntegration createSpringIntegration() {
        final Map&lt;String, Object&gt; capabilities = Map.of(
            &quot;proxy_support&quot;, true,
            &quot;factory_reset&quot;, true,
            &quot;dependency_injection&quot;, true,
            &quot;aop_support&quot;, true
        );
        return FrameworkIntegration.available(FrameworkType.SPRING, getSpringVersion(), capabilities);
    }

    private static FrameworkIntegration createCdiIntegration() {
        final Map&lt;String, Object&gt; capabilities = Map.of(
            &quot;proxy_support&quot;, true,
            &quot;factory_reset&quot;, false,
            &quot;dependency_injection&quot;, true,
            &quot;event_support&quot;, true
        );
        return FrameworkIntegration.available(FrameworkType.CDI, getCdiVersion(), capabilities);
    }

    private static FrameworkIntegration createGuiceIntegration() {
        final Map&lt;String, Object&gt; capabilities = Map.of(
            &quot;proxy_support&quot;, false,
            &quot;factory_reset&quot;, true,
            &quot;dependency_injection&quot;, true,
            &quot;module_support&quot;, true
        );
        return FrameworkIntegration.available(FrameworkType.GUICE, getGuiceVersion(), capabilities);
    }

    // Framework Annotation Detection

    private boolean hasSpringAnnotations(final Class&lt;?&gt; clazz) {
        try {
            return clazz.isAnnotationPresent(Class.forName(&quot;org.springframework.stereotype.Component&quot;)) ||
                   clazz.isAnnotationPresent(Class.forName(&quot;org.springframework.stereotype.Service&quot;)) ||
                   clazz.isAnnotationPresent(Class.forName(&quot;org.springframework.stereotype.Repository&quot;));
        } catch (final ClassNotFoundException e) {
            return false;
        }
    }

    private boolean hasCdiAnnotations(final Class&lt;?&gt; clazz) {
        try {
            return clazz.isAnnotationPresent(Class.forName(&quot;javax.enterprise.context.ApplicationScoped&quot;)) ||
                   clazz.isAnnotationPresent(Class.forName(&quot;javax.enterprise.context.RequestScoped&quot;)) ||
                   clazz.isAnnotationPresent(Class.forName(&quot;javax.inject.Singleton&quot;));
        } catch (final ClassNotFoundException e) {
            return false;
        }
    }

    private boolean hasGuiceAnnotations(final Class&lt;?&gt; clazz) {
        try {
            return clazz.isAnnotationPresent(Class.forName(&quot;com.google.inject.Singleton&quot;)) ||
                   clazz.isAnnotationPresent(Class.forName(&quot;javax.inject.Singleton&quot;));
        } catch (final ClassNotFoundException e) {
            return false;
        }
    }

    // Framework-Specific Update Methods

    private boolean updateSpringInstances(final Class&lt;?&gt; clazz, final byte[] newBytecode) {
        // Spring-specific instance update logic
        // This would integrate with Spring&#39;s ApplicationContext
        return true; // Simplified for documentation
    }

    private boolean updateCdiInstances(final Class&lt;?&gt; clazz, final byte[] newBytecode) {
        // CDI-specific instance update logic
        // This would integrate with CDI BeanManager
        return true; // Simplified for documentation
    }

    private boolean updateGuiceInstances(final Class&lt;?&gt; clazz, final byte[] newBytecode) {
        // Guice-specific instance update logic
        // This would integrate with Guice Injector
        return true; // Simplified for documentation
    }

    private boolean updatePlainJavaInstances(final Class&lt;?&gt; clazz, final byte[] newBytecode) {
        // Plain Java instance update using reflection
        return true; // Simplified for documentation
    }

    // Version Detection Methods

    private static String getSpringVersion() {
        try {
            final Class&lt;?&gt; versionClass = Class.forName(&quot;org.springframework.core.SpringVersion&quot;);
            final Method getVersionMethod = versionClass.getMethod(&quot;getVersion&quot;);
            return (String) getVersionMethod.invoke(null);
        } catch (final Exception e) {
            return &quot;unknown&quot;;
        }
    }

    private static String getCdiVersion() {
        return &quot;2.0&quot;; // Simplified for documentation
    }

    private static String getGuiceVersion() {
        return &quot;5.0&quot;; // Simplified for documentation
    }

    @Override
    public String toString() {
        return &quot;FrameworkIntegration{&quot; +
               &quot;type=&quot; + frameworkType +
               &quot;, available=&quot; + available +
               &quot;, version=&#39;&quot; + frameworkVersion + &#39;\&#39;&#39; +
               &quot;, managedClasses=&quot; + managedClasses.size() +
               &#39;}&#39;;
    }
}
</code></pre>
<h1 id="usage-examples">Usage Examples</h1>
<h2 id="framework-detection-and-selection">Framework Detection and
Selection</h2>
<p>// Detect available frameworks List&lt;FrameworkIntegration&gt;
frameworks = FrameworkIntegration.detectFrameworks();</p>
<p>// Find the best framework for a specific class Class&lt;?&gt;
targetClass = MyService.class; FrameworkIntegration bestFramework =
frameworks.stream() .filter(FrameworkIntegration::isAvailable) .filter(f
-&gt; f.canHandle(targetClass)) .findFirst() .orElse(frameworks.stream()
.filter(f -&gt; f.getFrameworkType() ==
FrameworkIntegration.FrameworkType.PLAIN<sub>JAVA</sub>) .findFirst()
.orElseThrow());</p>
<p>logger.info("Selected framework: {} for class: {}",
bestFramework.getFrameworkType(), targetClass.getName());</p>
<h2 id="framework-specific-instance-updates">Framework-Specific Instance
Updates</h2>
<pre class="java"><code>public boolean updateInstancesWithFramework(Class&lt;?&gt; clazz, byte[] newBytecode) {
    List&lt;FrameworkIntegration&gt; frameworks = FrameworkIntegration.detectFrameworks();

    for (FrameworkIntegration framework : frameworks) {
        if (framework.isAvailable() &amp;&amp; framework.canHandle(clazz)) {
            logger.info(&quot;Attempting update with framework: {}&quot;, framework.getFrameworkType());

            if (framework.updateInstances(clazz, newBytecode)) {
                logger.info(&quot;Successfully updated instances using {}&quot;, 
                           framework.getFrameworkType());

                // Track framework usage
                framework.addManagedClass(clazz);
                return true;
            } else {
                logger.warn(&quot;Failed to update instances using {}&quot;, 
                           framework.getFrameworkType());
            }
        }
    }

    logger.warn(&quot;No suitable framework found for class: {}&quot;, clazz.getName());
    return false;
}
</code></pre>
<h2 id="framework-capability-assessment">Framework Capability
Assessment</h2>
<p>public InstanceUpdateMethod
selectUpdateMethodForFramework(FrameworkIntegration framework,
Class&lt;?&gt; targetClass) { if (!framework.isAvailable() ||
!framework.canHandle(targetClass)) { return
InstanceUpdateMethod.REFLECTION; }</p>
<p>// Prefer framework-specific methods InstanceUpdateMethod recommended
= framework.getRecommendedUpdateMethod();</p>
<p>// Validate framework capabilities if (recommended ==
InstanceUpdateMethod.PROXY<sub>REFRESH</sub> &amp;&amp;
!framework.supportsProxyRefresh()) { logger.warn("Framework {} doesn't
support proxy refresh, falling back", framework.getFrameworkType());
recommended = InstanceUpdateMethod.REFLECTION; }</p>
<p>if (recommended == InstanceUpdateMethod.FACTORY<sub>RESET</sub>
&amp;&amp; !framework.supportsFactoryReset()) { logger.warn("Framework
{} doesn't support factory reset, falling back",
framework.getFrameworkType()); recommended =
InstanceUpdateMethod.REFLECTION; }</p>
<p>logger.info("Selected update method {} for framework {}",
recommended, framework.getFrameworkType());</p>
<p>return recommended; }</p>
<h2 id="framework-integration-analysis">Framework Integration
Analysis</h2>
<pre class="java"><code>public FrameworkAnalysisReport analyzeFrameworkUsage(List&lt;FrameworkIntegration&gt; frameworks) {
    FrameworkAnalysisReport report = new FrameworkAnalysisReport();

    for (FrameworkIntegration framework : frameworks) {
        FrameworkStats stats = new FrameworkStats();
        stats.setFrameworkType(framework.getFrameworkType());
        stats.setAvailable(framework.isAvailable());
        stats.setVersion(framework.getFrameworkVersion());
        stats.setManagedClassCount(framework.getManagedClasses().size());

        // Analyze capabilities
        if (framework.isAvailable()) {
            stats.setSupportsProxyRefresh(framework.supportsProxyRefresh());
            stats.setSupportsFactoryReset(framework.supportsFactoryReset());
            stats.setSupportsDependencyInjection(framework.supportsDependencyInjection());

            // Record capability usage
            if (framework.hasCapability(&quot;aop_support&quot;)) {
                stats.setAopSupport((Boolean) framework.getCapability(&quot;aop_support&quot;));
            }
        }

        report.addFrameworkStats(stats);
    }

    // Generate recommendations
    if (report.hasAvailableFrameworks()) {
        report.addRecommendation(&quot;Consider using framework-specific update methods for better performance&quot;);
    } else {
        report.addRecommendation(&quot;Consider integrating with Spring or CDI for advanced instance management&quot;);
    }

    return report;
}
</code></pre>
<h1 id="architecture-notes">Architecture Notes</h1>
<h2 id="framework-abstraction-layer">Framework Abstraction Layer</h2>
<ul>
<li>Unified interface for different dependency injection frameworks</li>
<li>Automatic framework detection and capability assessment</li>
<li>Framework-specific optimization strategies</li>
<li>Graceful fallback to reflection-based updates</li>
</ul>
<h2 id="strategy-pattern-implementation">Strategy Pattern
Implementation</h2>
<ul>
<li>Different update strategies for different frameworks</li>
<li>Framework-specific capability assessment</li>
<li>Configurable fallback mechanisms</li>
<li>Performance optimization through framework-native approaches</li>
</ul>
<h2 id="integration-design-principles">Integration Design
Principles</h2>
<ul>
<li>Non-intrusive framework integration</li>
<li>Optional dependency on external frameworks</li>
<li>Robust error handling and fallback mechanisms</li>
<li>Comprehensive framework capability reporting</li>
</ul>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 ByteHot Project. Licensed under <a href="https://www.gnu.org/licenses/gpl-3.0.html">GPLv3</a></p>
        <p>
            <a href="https://github.com/rydnr/bytehot">GitHub</a> ‚Ä¢ 
            <a href="https://github.com/rydnr/bytehot/issues">Issues</a> ‚Ä¢ 
            <a href="https://github.com/rydnr/bytehot/discussions">Discussions</a>
        </p>
    </footer>

    <script>
        // Matrix rain effect (lighter for documentation pages)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        document.querySelector('.matrix-bg').appendChild(canvas);
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const matrix = "BYTEHOT0123456789";
        const drops = [];
        for(let x = 0; x < canvas.width / 15; x++) { drops[x] = 1; }
        function draw() {
            ctx.fillStyle = 'rgba(15, 15, 35, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px Courier New';
            for(let i = 0; i < drops.length; i++) {
                const text = matrix[Math.floor(Math.random() * matrix.length)];
                ctx.fillText(text, i * 15, drops[i] * 15);
                if(drops[i] * 15 > canvas.height && Math.random() > 0.98) { drops[i] = 0; }
                drops[i]++;
            }
        }
        setInterval(draw, 50);
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
    </script>
</body>
</html>
