<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ErrorHandler - ByteHot Documentation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 100%); color: #00ff00; line-height: 1.6; overflow-x: hidden; }
        .matrix-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; opacity: 0.05; }
        .nav-header { position: fixed; top: 0; left: 0; right: 0; background: rgba(15, 15, 35, 0.95); backdrop-filter: blur(10px); padding: 1rem 2rem; z-index: 1000; border-bottom: 2px solid #00ff00; }
        .nav-links { display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; }
        .nav-link { color: #00ff00; text-decoration: none; padding: 0.4rem 0.8rem; border: 1px solid #00ff00; border-radius: 4px; transition: all 0.3s ease; font-weight: bold; font-size: 0.9rem; }
        .nav-link:hover { background: #00ff00; color: #0f0f23; box-shadow: 0 0 15px #00ff00; transform: translateY(-2px); }
        .content { margin-top: 100px; padding: 2rem; max-width: 1200px; margin-left: auto; margin-right: auto; }
        .doc-container { background: rgba(26, 26, 58, 0.8); border: 1px solid #00ff00; border-radius: 12px; padding: 3rem; margin: 2rem 0; }
        .doc-container h1 { color: #00cccc; font-size: 2.5rem; margin: 0 0 2rem 0; text-shadow: 0 0 15px #00cccc; text-align: center; }
        .doc-container h2 { color: #00ff00; font-size: 1.8rem; margin: 2rem 0 1rem 0; border-left: 4px solid #00ff00; padding-left: 1rem; text-shadow: 0 0 10px #00ff00; }
        .doc-container h3 { color: #00cccc; font-size: 1.4rem; margin: 1.5rem 0 1rem 0; }
        .doc-container h4, .doc-container h5, .doc-container h6 { color: #ffffff; margin: 1rem 0 0.5rem 0; }
        .doc-container p { color: #ffffff; margin: 1rem 0; line-height: 1.8; }
        .doc-container ul, .doc-container ol { color: #ffffff; margin: 1rem 0; padding-left: 2rem; }
        .doc-container li { margin: 0.5rem 0; line-height: 1.6; }
        .doc-container code { background: rgba(0, 0, 0, 0.5); color: #00ff00; padding: 0.2rem 0.4rem; border-radius: 4px; font-family: 'Courier New', monospace; border: 1px solid rgba(0, 255, 0, 0.3); }
        .doc-container pre { background: rgba(0, 0, 0, 0.8); border: 1px solid #00ff00; border-radius: 8px; padding: 1.5rem; overflow-x: auto; margin: 1.5rem 0; }
        .doc-container pre code { background: none; padding: 0; border: none; }
        .doc-container a { color: #00cccc; text-decoration: none; border-bottom: 1px dotted #00cccc; transition: all 0.3s ease; }
        .doc-container a:hover { color: #ffffff; border-bottom-color: #ffffff; text-shadow: 0 0 5px #00cccc; }
        .doc-container table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; background: rgba(0, 0, 0, 0.3); }
        .doc-container th, .doc-container td { border: 1px solid #00ff00; padding: 0.8rem; text-align: left; }
        .doc-container th { background: rgba(0, 255, 0, 0.1); color: #00ff00; font-weight: bold; }
        .doc-container td { color: #ffffff; }
        .doc-container blockquote { border-left: 4px solid #00cccc; padding-left: 1.5rem; margin: 1.5rem 0; color: #00cccc; font-style: italic; background: rgba(0, 204, 204, 0.05); padding: 1rem 1rem 1rem 1.5rem; border-radius: 0 8px 8px 0; }
        .footer { background: rgba(0, 0, 0, 0.8); padding: 2rem; text-align: center; border-top: 2px solid #00ff00; margin-top: 4rem; }
        .footer a { color: #00ff00; text-decoration: none; }
        .footer a:hover { text-shadow: 0 0 10px #00ff00; }
        @media (max-width: 768px) { .nav-links { gap: 0.8rem; } .nav-link { padding: 0.3rem 0.6rem; font-size: 0.8rem; } .content { padding: 1rem; } .doc-container { padding: 2rem; } .doc-container h1 { font-size: 2rem; } }
    </style>
</head>
<body>
    <div class="matrix-bg"></div>
    
    <nav class="nav-header">
        <div class="nav-links">
            <a href="index.html" class="nav-link">Home</a>
            <a href="story.html" class="nav-link">üìñ Story</a>
            <a href="GETTING_STARTED.html" class="nav-link">üöÄ Getting Started</a>
            <a href="implementation.html" class="nav-link">‚öôÔ∏è Implementation</a>
            <a href="literate-docs.html" class="nav-link">üìö Literate Docs</a>
            <a href="journal.html" class="nav-link">üìî Journal</a>
            <a href="javadocs/" class="nav-link">JavaDocs</a>
            <a href="https://github.com/rydnr/bytehot" class="nav-link">GitHub</a>
        </div>
    </nav>

    <div class="content">
        <div class="doc-container">
<h1 id="overview">Overview</h1>
<p>The <code class="verbatim">ErrorHandler</code> class serves as the
central coordinator for error handling in ByteHot operations. It
provides comprehensive error classification, severity assessment,
recovery strategy determination, and error pattern detection.</p>
<h2 id="key-responsibilities">Key Responsibilities</h2>
<ul>
<li>Classify errors into appropriate types and severity levels</li>
<li>Determine context-aware recovery strategies</li>
<li>Track error patterns and recurring issues</li>
<li>Provide thread-safe error handling operations</li>
<li>Maintain comprehensive error statistics</li>
</ul>
<h2 id="design-patterns">Design Patterns</h2>
<ul>
<li><strong>Strategy Pattern</strong>: For recovery strategy
selection</li>
<li><strong>Observer Pattern</strong>: For error pattern detection</li>
<li><strong>Factory Pattern</strong>: For error result creation</li>
</ul>
<h1 id="class-declaration-and-imports">Class Declaration and
Imports</h1>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/ErrorHandler.java"><code>/*
                        ByteHot

    Copyright (C) 2025-today  rydnr@acm-sl.org

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public v3
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Thanks to ACM S.L. for distributing this library under the GPLv3 license.
    Contact info: jose.sanleandro@acm-sl.com

 ******************************************************************************
 *
 * Filename: ErrorHandler.java
 *
 * Author: Claude Code
 *
 * Class name: ErrorHandler
 *
 * Responsibilities:
 *   - Central coordinator for error handling in ByteHot operations
 *   - Classify errors and determine appropriate recovery strategies
 *   - Track error patterns and provide comprehensive error context
 *
 * Collaborators:
 *   - ErrorResult: Contains error handling results
 *   - ErrorType: Classifies different types of errors
 *   - RecoveryStrategy: Defines recovery approaches
 *   - ClassRedefinitionFailed: Handles hot-swap failures
 */
package org.acmsl.bytehot.domain;

import org.acmsl.bytehot.domain.events.ClassRedefinitionFailed;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
</code></pre>
<h1 id="class-definition-and-state">Class Definition and State</h1>
<p>The <code class="verbatim">ErrorHandler</code> maintains thread-safe
state for tracking error counts and detecting patterns.</p>
<p>/**</p>
<ul>
<li>Central error handler for ByteHot operations</li>
<li>@author Claude Code</li>
<li>@since 2025-06-17</li>
</ul>
<p>*/ public class ErrorHandler {</p>
<p>/**</p>
<ul>
<li>Tracks error counts per class name</li>
</ul>
<p>*/ private final ConcurrentHashMap&lt;String, AtomicInteger&gt;
errorCounts = new ConcurrentHashMap&lt;&gt;();</p>
<p>/**</p>
<ul>
<li>Threshold for detecting error patterns</li>
</ul>
<p>*/ private static final int ERROR<sub>PATTERNTHRESHOLD</sub> = 3;</p>
<h1 id="core-error-handling-methods">Core Error Handling Methods</h1>
<h2 id="primary-error-handling">Primary Error Handling</h2>
<p>The main entry point for error handling provides a simple interface
while delegating to the more comprehensive method.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/ErrorHandler.java"><code>
/**
 * Handles a general error and determines recovery strategy
 * @param error the exception that occurred
 * @param className the class name where error occurred
 * @return error handling result with recovery strategy
 */
public ErrorResult handleError(final Throwable error, final String className) {
    return handleErrorWithContext(error, className, null);
}
</code></pre>
<h2 id="comprehensive-error-handling-with-context">Comprehensive Error
Handling with Context</h2>
<p>This method provides the complete error handling workflow including
classification, severity assessment, and recovery strategy
determination.</p>
<p>/**</p>
<ul>
<li>Handles an error with full context information</li>
<li>@param error the exception that occurred</li>
<li>@param className the class name where error occurred</li>
<li>@param operation the operation being performed</li>
<li>@return error handling result with recovery strategy</li>
</ul>
<p>*/ public ErrorResult handleErrorWithContext(final Throwable error,
final String className, final String operation) { // Increment error
count for this class if (className != null) {
errorCounts.computeIfAbsent(className, k -&gt; new
AtomicInteger(0)).incrementAndGet(); }</p>
<p>// Classify the error type final ErrorType errorType =
classifyError(error);</p>
<p>// Assess severity final ErrorSeverity severity =
assessSeverity(error);</p>
<p>// Determine recovery strategy based on error type and context final
RecoveryStrategy strategy = determineRecoveryStrategy(errorType, error,
operation);</p>
<p>// Determine if error is recoverable final boolean recoverable =
isRecoverable(errorType, severity);</p>
<p>// Build error message final String errorMessage =
buildErrorMessage(error, className, operation);</p>
<p>return ErrorResult.create( errorType, severity, strategy,
recoverable, errorMessage, className, operation, error ); }</p>
<h2 id="specialized-redefinition-failure-handling">Specialized
Redefinition Failure Handling</h2>
<p>Special handling for class redefinition failures, which are common in
hot-swap operations.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/ErrorHandler.java"><code>
/**
 * Handles class redefinition failure specifically
 * @param redefinitionFailed the redefinition failure event
 * @return error handling result
 */
public ErrorResult handleRedefinitionFailure(final ClassRedefinitionFailed redefinitionFailed) {
    final String className = redefinitionFailed.getClassName();

    // Track error for this class
    errorCounts.computeIfAbsent(className, k -&gt; new AtomicInteger(0)).incrementAndGet();

    final String errorMessage = &quot;Class redefinition failed: &quot; + redefinitionFailed.getFailureReason() +
                               &quot; (JVM Error: &quot; + redefinitionFailed.getJvmError() + &quot;)&quot;;

    return ErrorResult.create(
        ErrorType.REDEFINITION_FAILURE,
        ErrorSeverity.ERROR,
        RecoveryStrategy.ROLLBACK_CHANGES,
        true, // Redefinition failures are generally recoverable
        errorMessage,
        className,
        &quot;class-redefinition&quot;,
        null // No specific exception cause in this event
    );
}
</code></pre>
<h1 id="error-analysis-methods">Error Analysis Methods</h1>
<h2 id="severity-assessment">Severity Assessment</h2>
<p>Determines the severity level of an error based on its type and
characteristics.</p>
<p>/**</p>
<ul>
<li>Assesses the severity of an error</li>
<li>@param error the exception</li>
<li>@return severity level</li>
</ul>
<p>*/ public ErrorSeverity assessSeverity(final Throwable error) { if
(error instanceof OutOfMemoryError || error instanceof
StackOverflowError) { return ErrorSeverity.CRITICAL; }</p>
<p>if (error instanceof SecurityException) { return ErrorSeverity.ERROR;
}</p>
<p>if (error instanceof IllegalArgumentException || error instanceof
IllegalStateException) { return ErrorSeverity.WARNING; }</p>
<p>if (error instanceof RuntimeException) { return ErrorSeverity.ERROR;
}</p>
<p>return ErrorSeverity.ERROR; // Default severity }</p>
<h2 id="error-pattern-detection">Error Pattern Detection</h2>
<p>Provides methods for tracking error patterns and detecting recurring
issues.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/ErrorHandler.java"><code>
/**
 * Gets the error count for a specific class
 * @param className the class name
 * @return number of errors for this class
 */
public int getErrorCount(final String className) {
    final AtomicInteger count = errorCounts.get(className);
    return count != null ? count.get() : 0;
}

/**
 * Detects if there&#39;s an error pattern for a class
 * @param className the class name
 * @return true if error pattern detected
 */
public boolean detectErrorPattern(final String className) {
    return getErrorCount(className) &gt;= ERROR_PATTERN_THRESHOLD;
}
</code></pre>
<h1 id="error-classification-and-strategy-methods">Error Classification
and Strategy Methods</h1>
<h2 id="error-type-classification">Error Type Classification</h2>
<p>Classifies errors into specific types for appropriate handling.</p>
<p>/**</p>
<ul>
<li>Classifies the type of error based on the exception</li>
<li>@param error the exception</li>
<li>@return error type classification</li>
</ul>
<p>*/ protected ErrorType classifyError(final Throwable error) { if
(error instanceof BytecodeValidationException) { return
ErrorType.VALIDATION<sub>ERROR</sub>; }</p>
<p>if (error instanceof InstanceUpdateException) { return
ErrorType.INSTANCE<sub>UPDATEERROR</sub>; }</p>
<p>if (error instanceof HotSwapException) { return
ErrorType.REDEFINITION<sub>FAILURE</sub>; }</p>
<p>if (error instanceof SecurityException) { return
ErrorType.SECURITY<sub>ERROR</sub>; }</p>
<p>if (error instanceof OutOfMemoryError || error instanceof
StackOverflowError) { return ErrorType.CRITICAL<sub>SYSTEMERROR</sub>;
}</p>
<p>if (error instanceof java.nio.file.NoSuchFileException || error
instanceof java.nio.file.AccessDeniedException) { return
ErrorType.FILE<sub>SYSTEMERROR</sub>; }</p>
<p>return ErrorType.UNKNOWN<sub>ERROR</sub>; // Default classification
}</p>
<h2 id="recovery-strategy-determination">Recovery Strategy
Determination</h2>
<p>Determines the appropriate recovery strategy based on error type and
context.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/ErrorHandler.java"><code>
/**
 * Determines the recovery strategy based on error type and context
 * @param errorType the classified error type
 * @param error the original exception
 * @param operation the operation being performed
 * @return recommended recovery strategy
 */
protected RecoveryStrategy determineRecoveryStrategy(final ErrorType errorType, final Throwable error, final String operation) {
    switch (errorType) {
        case VALIDATION_ERROR:
            return RecoveryStrategy.REJECT_CHANGE;

        case REDEFINITION_FAILURE:
            return RecoveryStrategy.ROLLBACK_CHANGES;

        case INSTANCE_UPDATE_ERROR:
            return RecoveryStrategy.PRESERVE_CURRENT_STATE;

        case CRITICAL_SYSTEM_ERROR:
            return RecoveryStrategy.EMERGENCY_SHUTDOWN;

        case SECURITY_ERROR:
            return RecoveryStrategy.MANUAL_INTERVENTION;

        case FILE_SYSTEM_ERROR:
            return RecoveryStrategy.RETRY_OPERATION;

        case CONFIGURATION_ERROR:
            return RecoveryStrategy.FALLBACK_MODE;

        default:
            return RecoveryStrategy.NO_ACTION;
    }
}
</code></pre>
<h1 id="utility-methods">Utility Methods</h1>
<h2 id="recoverability-assessment">Recoverability Assessment</h2>
<p>Determines if an error is recoverable based on its type and
severity.</p>
<p>/**</p>
<ul>
<li>Determines if an error is recoverable based on type and
severity</li>
<li>@param errorType the error type</li>
<li>@param severity the error severity</li>
<li>@return true if error is recoverable</li>
</ul>
<p>*/ protected boolean isRecoverable(final ErrorType errorType, final
ErrorSeverity severity) { // Critical system errors are generally not
recoverable if (errorType == ErrorType.CRITICAL<sub>SYSTEMERROR</sub> ||
severity == ErrorSeverity.FATAL) { return false; }</p>
<p>// Most other errors are recoverable with appropriate strategies
return true; }</p>
<h2 id="error-message-building">Error Message Building</h2>
<p>Constructs comprehensive error messages with context information.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/ErrorHandler.java"><code>
    /**
     * Builds a comprehensive error message
     * @param error the exception
     * @param className the class name
     * @param operation the operation
     * @return formatted error message
     */
    protected String buildErrorMessage(final Throwable error, final String className, final String operation) {
        final StringBuilder message = new StringBuilder();

        if (operation != null) {
            message.append(&quot;Operation &#39;&quot;).append(operation).append(&quot;&#39; failed&quot;);
        } else {
            message.append(&quot;Error occurred&quot;);
        }

        if (className != null) {
            message.append(&quot; for class &quot;).append(className);
        }

        message.append(&quot;: &quot;).append(error.getMessage());

        return message.toString();
    }
}
</code></pre>
<h1 id="usage-examples">Usage Examples</h1>
<h2 id="basic-error-handling">Basic Error Handling</h2>
<p>ErrorHandler errorHandler = new ErrorHandler();</p>
<p>try { // Some ByteHot operation } catch (Exception e) { ErrorResult
result = errorHandler.handleError(e, "com.example.MyClass");</p>
<p>if (result.isRecoverable()) { // Apply recovery strategy
RecoveryStrategy strategy = result.getRecoveryStrategy(); // ‚Ä¶ implement
recovery } }</p>
<h2 id="error-pattern-detection-1">Error Pattern Detection</h2>
<pre class="java"><code>// Check for error patterns
if (errorHandler.detectErrorPattern(&quot;com.example.ProblematicClass&quot;)) {
    // Take preventive action
    System.out.println(&quot;Error pattern detected for ProblematicClass&quot;);
}
</code></pre>
<h1 id="architecture-notes">Architecture Notes</h1>
<h2 id="thread-safety">Thread Safety</h2>
<ul>
<li>Uses <code class="verbatim">ConcurrentHashMap</code> for thread-safe
error counting</li>
<li><code class="verbatim">AtomicInteger</code> for atomic counter
operations</li>
<li>All methods are thread-safe and can be called concurrently</li>
</ul>
<h2 id="error-classification-strategy">Error Classification
Strategy</h2>
<ul>
<li>Hierarchical error classification from most specific to most
general</li>
<li>Context-aware recovery strategy selection</li>
<li>Extensible design for adding new error types and strategies</li>
</ul>
<h2 id="performance-considerations">Performance Considerations</h2>
<ul>
<li>Efficient error counting with minimal synchronization overhead</li>
<li>Pattern detection with configurable thresholds</li>
<li>Lazy initialization of error tracking structures</li>
</ul>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 ByteHot Project. Licensed under <a href="https://www.gnu.org/licenses/gpl-3.0.html">GPLv3</a></p>
        <p>
            <a href="https://github.com/rydnr/bytehot">GitHub</a> ‚Ä¢ 
            <a href="https://github.com/rydnr/bytehot/issues">Issues</a> ‚Ä¢ 
            <a href="https://github.com/rydnr/bytehot/discussions">Discussions</a>
        </p>
    </footer>

    <script>
        // Matrix rain effect (lighter for documentation pages)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        document.querySelector('.matrix-bg').appendChild(canvas);
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const matrix = "BYTEHOT0123456789";
        const drops = [];
        for(let x = 0; x < canvas.width / 15; x++) { drops[x] = 1; }
        function draw() {
            ctx.fillStyle = 'rgba(15, 15, 35, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px Courier New';
            for(let i = 0; i < drops.length; i++) {
                const text = matrix[Math.floor(Math.random() * matrix.length)];
                ctx.fillText(text, i * 15, drops[i] * 15);
                if(drops[i] * 15 > canvas.height && Math.random() > 0.98) { drops[i] = 0; }
                drops[i]++;
            }
        }
        setInterval(draw, 50);
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
    </script>
</body>
</html>
