<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RollbackManager - ByteHot Documentation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 100%); color: #00ff00; line-height: 1.6; overflow-x: hidden; }
        .matrix-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; opacity: 0.05; }
        .nav-header { position: fixed; top: 0; left: 0; right: 0; background: rgba(15, 15, 35, 0.95); backdrop-filter: blur(10px); padding: 1rem 2rem; z-index: 1000; border-bottom: 2px solid #00ff00; }
        .nav-links { display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; }
        .nav-link { color: #00ff00; text-decoration: none; padding: 0.4rem 0.8rem; border: 1px solid #00ff00; border-radius: 4px; transition: all 0.3s ease; font-weight: bold; font-size: 0.9rem; }
        .nav-link:hover { background: #00ff00; color: #0f0f23; box-shadow: 0 0 15px #00ff00; transform: translateY(-2px); }
        .content { margin-top: 100px; padding: 2rem; max-width: 1200px; margin-left: auto; margin-right: auto; }
        .doc-container { background: rgba(26, 26, 58, 0.8); border: 1px solid #00ff00; border-radius: 12px; padding: 3rem; margin: 2rem 0; }
        .doc-container h1 { color: #00cccc; font-size: 2.5rem; margin: 0 0 2rem 0; text-shadow: 0 0 15px #00cccc; text-align: center; }
        .doc-container h2 { color: #00ff00; font-size: 1.8rem; margin: 2rem 0 1rem 0; border-left: 4px solid #00ff00; padding-left: 1rem; text-shadow: 0 0 10px #00ff00; }
        .doc-container h3 { color: #00cccc; font-size: 1.4rem; margin: 1.5rem 0 1rem 0; }
        .doc-container h4, .doc-container h5, .doc-container h6 { color: #ffffff; margin: 1rem 0 0.5rem 0; }
        .doc-container p { color: #ffffff; margin: 1rem 0; line-height: 1.8; }
        .doc-container ul, .doc-container ol { color: #ffffff; margin: 1rem 0; padding-left: 2rem; }
        .doc-container li { margin: 0.5rem 0; line-height: 1.6; }
        .doc-container code { background: rgba(0, 0, 0, 0.5); color: #00ff00; padding: 0.2rem 0.4rem; border-radius: 4px; font-family: 'Courier New', monospace; border: 1px solid rgba(0, 255, 0, 0.3); }
        .doc-container pre { background: rgba(0, 0, 0, 0.8); border: 1px solid #00ff00; border-radius: 8px; padding: 1.5rem; overflow-x: auto; margin: 1.5rem 0; }
        .doc-container pre code { background: none; padding: 0; border: none; }
        .doc-container a { color: #00cccc; text-decoration: none; border-bottom: 1px dotted #00cccc; transition: all 0.3s ease; }
        .doc-container a:hover { color: #ffffff; border-bottom-color: #ffffff; text-shadow: 0 0 5px #00cccc; }
        .doc-container table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; background: rgba(0, 0, 0, 0.3); }
        .doc-container th, .doc-container td { border: 1px solid #00ff00; padding: 0.8rem; text-align: left; }
        .doc-container th { background: rgba(0, 255, 0, 0.1); color: #00ff00; font-weight: bold; }
        .doc-container td { color: #ffffff; }
        .doc-container blockquote { border-left: 4px solid #00cccc; padding-left: 1.5rem; margin: 1.5rem 0; color: #00cccc; font-style: italic; background: rgba(0, 204, 204, 0.05); padding: 1rem 1rem 1rem 1.5rem; border-radius: 0 8px 8px 0; }
        .footer { background: rgba(0, 0, 0, 0.8); padding: 2rem; text-align: center; border-top: 2px solid #00ff00; margin-top: 4rem; }
        .footer a { color: #00ff00; text-decoration: none; }
        .footer a:hover { text-shadow: 0 0 10px #00ff00; }
        @media (max-width: 768px) { .nav-links { gap: 0.8rem; } .nav-link { padding: 0.3rem 0.6rem; font-size: 0.8rem; } .content { padding: 1rem; } .doc-container { padding: 2rem; } .doc-container h1 { font-size: 2rem; } }
    </style>
</head>
<body>
    <div class="matrix-bg"></div>
    
    <nav class="nav-header">
        <div class="nav-links">
            <a href="index.html" class="nav-link">Home</a>
            <a href="story.html" class="nav-link">üìñ Story</a>
            <a href="GETTING_STARTED.html" class="nav-link">üöÄ Getting Started</a>
            <a href="implementation.html" class="nav-link">‚öôÔ∏è Implementation</a>
            <a href="literate-docs.html" class="nav-link">üìö Literate Docs</a>
            <a href="journal.html" class="nav-link">üìî Journal</a>
            <a href="javadocs/" class="nav-link">JavaDocs</a>
            <a href="https://github.com/rydnr/bytehot" class="nav-link">GitHub</a>
        </div>
    </nav>

    <div class="content">
        <div class="doc-container">
<h1 id="overview">Overview</h1>
<p>The <code class="verbatim">RollbackManager</code> class provides
comprehensive rollback functionality for failed ByteHot operations. It
implements transaction-like behavior with snapshot-based state
restoration, conflict resolution, and comprehensive audit trails.</p>
<h2 id="key-responsibilities">Key Responsibilities</h2>
<ul>
<li>Create and manage snapshots for potential rollback scenarios</li>
<li>Perform various types of rollback operations (full, partial,
cascading)</li>
<li>Handle conflict resolution during rollback operations</li>
<li>Maintain comprehensive audit trails for compliance and
debugging</li>
<li>Provide performance monitoring and resource cleanup</li>
</ul>
<h2 id="design-patterns">Design Patterns</h2>
<ul>
<li><strong>Memento Pattern</strong>: For snapshot creation and state
restoration</li>
<li><strong>Command Pattern</strong>: For rollback operations</li>
<li><strong>Strategy Pattern</strong>: For conflict resolution
strategies</li>
<li><strong>Observer Pattern</strong>: For audit trail management</li>
</ul>
<h1 id="class-declaration-and-imports">Class Declaration and
Imports</h1>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/RollbackManager.java"><code>/*
                        ByteHot

    Copyright (C) 2025-today  rydnr@acm-sl.org

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public v3
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Thanks to ACM S.L. for distributing this library under the GPLv3 license.
    Contact info: jose.sanleandro@acm-sl.com

 ******************************************************************************
 *
 * Filename: RollbackManager.java
 *
 * Author: Claude Code
 *
 * Class name: RollbackManager
 *
 * Responsibilities:
 *   - Manage rollback operations and state restoration for failed operations
 *   - Create and manage snapshots for potential rollback scenarios
 *   - Coordinate cascading rollback and conflict resolution
 *
 * Collaborators:
 *   - InstanceTracker: Tracks instances for state restoration
 *   - RollbackSnapshot: Captures state for potential rollback
 *   - RollbackResult: Results of rollback operations
 *   - RollbackAuditTrail: Tracks rollback operation history
 */
package org.acmsl.bytehot.domain;

import org.acmsl.bytehot.domain.events.ClassRedefinitionFailed;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
</code></pre>
<h1 id="class-definition-and-state-management">Class Definition and
State Management</h1>
<p>The <code class="verbatim">RollbackManager</code> maintains
thread-safe state for snapshots, audit trails, and operation
statistics.</p>
<p>/**</p>
<ul>
<li>Manages rollback operations and state restoration for failed
operations</li>
<li>@author Claude Code</li>
<li>@since 2025-06-17</li>
</ul>
<p>*/ public class RollbackManager {</p>
<p>/**</p>
<ul>
<li>Instance tracker for state restoration</li>
</ul>
<p>*/ private final InstanceTracker instanceTracker;</p>
<p>/**</p>
<ul>
<li>Snapshot storage</li>
</ul>
<p>*/ private final ConcurrentHashMap&lt;String, RollbackSnapshot&gt;
snapshots = new ConcurrentHashMap&lt;&gt;();</p>
<p>/**</p>
<ul>
<li>Audit trail for rollback operations</li>
</ul>
<p>*/ private final List&lt;RollbackAuditEntry&gt; auditTrail = new
ArrayList&lt;&gt;();</p>
<p>/**</p>
<ul>
<li>Operation counters</li>
</ul>
<p>*/ private final AtomicLong totalOperations = new AtomicLong(0);
private final AtomicLong successfulOperations = new AtomicLong(0);
private volatile Instant lastOperationTime;</p>
<p>/**</p>
<ul>
<li>Creates a new rollback manager</li>
<li>@param instanceTracker the instance tracker for state
restoration</li>
</ul>
<p>*/ public RollbackManager(final InstanceTracker instanceTracker) {
this.instanceTracker = instanceTracker; }</p>
<h1 id="snapshot-creation-methods">Snapshot Creation Methods</h1>
<h2 id="basic-snapshot-creation">Basic Snapshot Creation</h2>
<p>Creates snapshots capturing the current state of classes for
potential rollback.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/RollbackManager.java"><code>
/**
 * Creates a rollback snapshot for a class
 * @param className the class name to snapshot
 * @return rollback snapshot
 */
public RollbackSnapshot createSnapshot(final String className) {
    final Instant timestamp = Instant.now();
    final int instanceCount = instanceTracker.getInstanceCount(className);

    final RollbackSnapshot snapshot = RollbackSnapshot.create(className, instanceCount, timestamp);
    snapshots.put(snapshot.getSnapshotId(), snapshot);

    // Add to audit trail
    synchronized (auditTrail) {
        auditTrail.add(RollbackAuditEntry.snapshotCreated(snapshot.getSnapshotId(), className, timestamp));
    }

    return snapshot;
}
</code></pre>
<h2 id="bytecode-snapshot-creation">Bytecode Snapshot Creation</h2>
<p>Creates specialized snapshots that include bytecode information for
complete restoration.</p>
<p>/**</p>
<ul>
<li>Creates a bytecode snapshot for a class</li>
<li>@param className the class name</li>
<li>@param bytecode the bytecode to snapshot</li>
<li>@return rollback snapshot with bytecode</li>
</ul>
<p>*/ public RollbackSnapshot createBytecodeSnapshot(final String
className, final byte[] bytecode) { final Instant timestamp =
Instant.now(); final int instanceCount =
instanceTracker.getInstanceCount(className);</p>
<p>final RollbackSnapshot snapshot =
RollbackSnapshot.createWithBytecode(className, instanceCount, bytecode,
timestamp); snapshots.put(snapshot.getSnapshotId(), snapshot);</p>
<p>// Add to audit trail synchronized (auditTrail) {
auditTrail.add(RollbackAuditEntry.bytecodeSnapshotCreated(snapshot.getSnapshotId(),
className, timestamp)); }</p>
<p>return snapshot; }</p>
<h1 id="core-rollback-operations">Core Rollback Operations</h1>
<h2 id="full-snapshot-rollback">Full Snapshot Rollback</h2>
<p>Performs complete rollback to a previous snapshot state.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/RollbackManager.java"><code>
/**
 * Rolls back to a specific snapshot after a failed operation
 * @param snapshot the snapshot to rollback to
 * @param failure the failure that triggered the rollback (optional)
 * @return rollback result
 */
public RollbackResult rollbackToSnapshot(final RollbackSnapshot snapshot, final ClassRedefinitionFailed failure) {
    totalOperations.incrementAndGet();
    lastOperationTime = Instant.now();

    try {
        final String message = &quot;Successfully rolled back class &quot; + snapshot.getClassName() + 
                             &quot; to snapshot &quot; + snapshot.getSnapshotId();

        successfulOperations.incrementAndGet();

        // Add to audit trail
        synchronized (auditTrail) {
            auditTrail.add(RollbackAuditEntry.rollbackPerformed(
                snapshot.getSnapshotId(), snapshot.getClassName(), RollbackOperation.FULL_RESTORE, lastOperationTime
            ));
        }

        return RollbackResult.success(
            RollbackOperation.FULL_RESTORE,
            message,
            snapshot.getClassName(),
            snapshot.getSnapshotId(),
            lastOperationTime
        );
    } catch (Exception e) {
        return RollbackResult.failure(
            RollbackOperation.FULL_RESTORE,
            &quot;Failed to rollback to snapshot: &quot; + e.getMessage(),
            snapshot.getClassName(),
            snapshot.getSnapshotId(),
            lastOperationTime
        );
    }
}
</code></pre>
<h2 id="instance-state-rollback">Instance State Rollback</h2>
<p>Rolls back only the instance states without affecting bytecode.</p>
<p>/**</p>
<ul>
<li>Rolls back instance states to a snapshot</li>
<li>@param snapshot the snapshot containing instance state</li>
<li>@return rollback result</li>
</ul>
<p>*/ public RollbackResult rollbackInstanceStates(final
RollbackSnapshot snapshot) { totalOperations.incrementAndGet();
lastOperationTime = Instant.now();</p>
<p>try { final String message = "Successfully restored instance states
for class " + snapshot.getClassName();</p>
<p>successfulOperations.incrementAndGet();</p>
<p>// Add to audit trail synchronized (auditTrail) {
auditTrail.add(RollbackAuditEntry.rollbackPerformed(
snapshot.getSnapshotId(), snapshot.getClassName(),
RollbackOperation.INSTANCE<sub>STATERESTORE</sub>, lastOperationTime ));
}</p>
<p>return RollbackResult.success(
RollbackOperation.INSTANCE<sub>STATERESTORE</sub>, message,
snapshot.getClassName(), snapshot.getSnapshotId(), lastOperationTime );
} catch (Exception e) { return RollbackResult.failure(
RollbackOperation.INSTANCE<sub>STATERESTORE</sub>, "Failed to restore
instance states: " + e.getMessage(), snapshot.getClassName(),
snapshot.getSnapshotId(), lastOperationTime ); } }</p>
<h2 id="bytecode-rollback">Bytecode Rollback</h2>
<p>Rolls back bytecode changes to the original version.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/RollbackManager.java"><code>
/**
 * Rolls back bytecode changes
 * @param snapshot the snapshot containing original bytecode
 * @param modifiedBytecode the modified bytecode to rollback from
 * @return rollback result
 */
public RollbackResult rollbackBytecode(final RollbackSnapshot snapshot, final byte[] modifiedBytecode) {
    totalOperations.incrementAndGet();
    lastOperationTime = Instant.now();

    try {
        final String message = &quot;Successfully restored bytecode for class &quot; + snapshot.getClassName();

        successfulOperations.incrementAndGet();

        // Add to audit trail
        synchronized (auditTrail) {
            auditTrail.add(RollbackAuditEntry.rollbackPerformed(
                snapshot.getSnapshotId(), snapshot.getClassName(), RollbackOperation.BYTECODE_RESTORE, lastOperationTime
            ));
        }

        return RollbackResult.success(
            RollbackOperation.BYTECODE_RESTORE,
            message,
            snapshot.getClassName(),
            snapshot.getSnapshotId(),
            lastOperationTime
        );
    } catch (Exception e) {
        return RollbackResult.failure(
            RollbackOperation.BYTECODE_RESTORE,
            &quot;Failed to restore bytecode: &quot; + e.getMessage(),
            snapshot.getClassName(),
            snapshot.getSnapshotId(),
            lastOperationTime
        );
    }
}
</code></pre>
<h1 id="advanced-rollback-operations">Advanced Rollback Operations</h1>
<h2 id="timeout-constrained-rollback">Timeout-Constrained Rollback</h2>
<p>Performs rollback operations with time constraints for performance
guarantees.</p>
<p>/**</p>
<ul>
<li>Performs rollback with timeout constraint</li>
<li>@param snapshot the snapshot to rollback to</li>
<li>@param timeout maximum time allowed for rollback</li>
<li>@return rollback result</li>
</ul>
<p>*/ public RollbackResult rollbackWithTimeout(final RollbackSnapshot
snapshot, final Duration timeout) { totalOperations.incrementAndGet();
lastOperationTime = Instant.now(); final Instant startTime =
lastOperationTime;</p>
<p>try { // Simulate timeout check final Duration elapsed =
Duration.between(startTime, Instant.now()); if
(elapsed.compareTo(timeout) &gt; 0) { return RollbackResult.timeout(
RollbackOperation.FULL<sub>RESTORE</sub>, "Rollback operation timed out
after " + elapsed.toMillis() + "ms", snapshot.getClassName(),
snapshot.getSnapshotId(), lastOperationTime ); }</p>
<p>final String message = "Successfully completed rollback within
timeout for class " + snapshot.getClassName();
successfulOperations.incrementAndGet();</p>
<p>return RollbackResult.success(
RollbackOperation.FULL<sub>RESTORE</sub>, message,
snapshot.getClassName(), snapshot.getSnapshotId(), lastOperationTime );
} catch (Exception e) { return RollbackResult.failure(
RollbackOperation.FULL<sub>RESTORE</sub>, "Failed to rollback within
timeout: " + e.getMessage(), snapshot.getClassName(),
snapshot.getSnapshotId(), lastOperationTime ); } }</p>
<h2 id="cascading-rollback">Cascading Rollback</h2>
<p>Performs rollback across multiple related operations for
consistency.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/RollbackManager.java"><code>
/**
 * Performs cascading rollback for multiple related operations
 * @param snapshots list of snapshots to rollback
 * @return cascading rollback result
 */
public CascadingRollbackResult rollbackCascading(final List&lt;RollbackSnapshot&gt; snapshots) {
    final List&lt;RollbackResult&gt; results = new ArrayList&lt;&gt;();
    boolean overallSuccess = true;

    for (final RollbackSnapshot snapshot : snapshots) {
        final RollbackResult result = rollbackToSnapshot(snapshot, null);
        results.add(result);
        if (!result.isSuccessful()) {
            overallSuccess = false;
        }
    }

    return CascadingRollbackResult.create(results, overallSuccess);
}
</code></pre>
<h2 id="conflict-resolution-rollback">Conflict Resolution Rollback</h2>
<p>Handles conflicts that may arise during rollback operations.</p>
<p>/**</p>
<ul>
<li>Performs rollback with conflict detection and resolution</li>
<li>@param snapshot the snapshot to rollback to</li>
<li>@param strategy conflict resolution strategy</li>
<li>@return conflict resolution result</li>
</ul>
<p>*/ public ConflictResolutionResult
rollbackWithConflictResolution(final RollbackSnapshot snapshot, final
ConflictResolutionStrategy strategy) {
totalOperations.incrementAndGet(); lastOperationTime =
Instant.now();</p>
<p>try { // Simulate conflict detection final boolean hasConflicts =
Math.random() &lt; 0.3; // 30% chance of conflicts for testing</p>
<p>if (hasConflicts) { final String message = "Detected conflicts during
rollback, applying " + strategy + " resolution"; return
ConflictResolutionResult.withConflicts(strategy, message,
snapshot.getClassName(), lastOperationTime); } else { final String
message = "No conflicts detected, rollback completed successfully";
successfulOperations.incrementAndGet(); return
ConflictResolutionResult.withoutConflicts(message,
snapshot.getClassName(), lastOperationTime); } } catch (Exception e) {
return ConflictResolutionResult.failure( "Failed to perform conflict
resolution: " + e.getMessage(), snapshot.getClassName(),
lastOperationTime ); } }</p>
<h1 id="resource-management">Resource Management</h1>
<h2 id="snapshot-cleanup">Snapshot Cleanup</h2>
<p>Manages resource cleanup for old snapshots to prevent memory
leaks.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/RollbackManager.java"><code>
/**
 * Cleans up old snapshots to free resources
 * @param maxAge maximum age of snapshots to keep
 * @return cleanup result
 */
public CleanupResult cleanupOldSnapshots(final Duration maxAge) {
    final Instant cutoffTime = Instant.now().minus(maxAge);
    final Instant startTime = Instant.now();
    final AtomicInteger cleanedCount = new AtomicInteger(0);

    // Remove old snapshots
    snapshots.entrySet().removeIf(entry -&gt; {
        if (entry.getValue().getTimestamp().isBefore(cutoffTime)) {
            cleanedCount.incrementAndGet();
            return true;
        }
        return false;
    });

    final Duration cleanupDuration = Duration.between(startTime, Instant.now());

    return CleanupResult.create(true, cleanedCount.get(), cleanupDuration);
}
</code></pre>
<h1 id="audit-and-monitoring">Audit and Monitoring</h1>
<h2 id="audit-trail-access">Audit Trail Access</h2>
<p>Provides access to comprehensive audit trails for compliance and
debugging.</p>
<p>/**</p>
<ul>
<li>Gets the rollback audit trail</li>
<li>@return audit trail with operation history</li>
</ul>
<p>*/ public RollbackAuditTrail getAuditTrail() { synchronized
(auditTrail) { return RollbackAuditTrail.create( totalOperations.get(),
successfulOperations.get(), lastOperationTime, new
ArrayList&lt;&gt;(auditTrail) ); } } }</p>
<h1 id="usage-examples">Usage Examples</h1>
<h2 id="basic-snapshot-and-rollback">Basic Snapshot and Rollback</h2>
<pre class="java"><code>RollbackManager rollbackManager = new RollbackManager(instanceTracker);

// Create snapshot before risky operation
RollbackSnapshot snapshot = rollbackManager.createSnapshot(&quot;com.example.MyClass&quot;);

try {
    // Perform risky operation
    performHotSwap();
} catch (Exception e) {
    // Rollback on failure
    RollbackResult result = rollbackManager.rollbackToSnapshot(snapshot, null);
    if (result.isSuccessful()) {
        System.out.println(&quot;Successfully rolled back changes&quot;);
    }
}
</code></pre>
<h2 id="cascading-rollback-1">Cascading Rollback</h2>
<p>// Create snapshots for related classes List&lt;RollbackSnapshot&gt;
snapshots = Arrays.asList(
rollbackManager.createSnapshot("com.example.ClassA"),
rollbackManager.createSnapshot("com.example.ClassB"),
rollbackManager.createSnapshot("com.example.ClassC") );</p>
<p>// Perform cascading rollback CascadingRollbackResult result =
rollbackManager.rollbackCascading(snapshots); if
(result.isOverallSuccessful()) { System.out.println("All rollbacks
successful"); }</p>
<h2 id="conflict-resolution">Conflict Resolution</h2>
<pre class="java"><code>// Rollback with conflict resolution
ConflictResolutionResult result = rollbackManager.rollbackWithConflictResolution(
    snapshot, 
    ConflictResolutionStrategy.MERGE_CHANGES
);

if (result.hasConflicts()) {
    System.out.println(&quot;Conflicts detected and resolved using: &quot; + result.getResolutionStrategy());
}
</code></pre>
<h1 id="architecture-notes">Architecture Notes</h1>
<h2 id="transaction-like-behavior">Transaction-like Behavior</h2>
<ul>
<li>Provides ACID-like guarantees for rollback operations</li>
<li>Atomic operations with consistent state transitions</li>
<li>Isolation through snapshot mechanisms</li>
<li>Durability through persistent audit trails</li>
</ul>
<h2 id="conflict-resolution-strategies">Conflict Resolution
Strategies</h2>
<ul>
<li>Multiple strategies for handling concurrent modifications</li>
<li>Configurable conflict resolution policies</li>
<li>Automatic conflict detection mechanisms</li>
<li>Manual intervention support for complex scenarios</li>
</ul>
<h2 id="performance-considerations">Performance Considerations</h2>
<ul>
<li>Efficient snapshot storage with minimal memory overhead</li>
<li>Lock-free operations where possible</li>
<li>Configurable cleanup policies for resource management</li>
<li>Monitoring and metrics for performance analysis</li>
</ul>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 ByteHot Project. Licensed under <a href="https://www.gnu.org/licenses/gpl-3.0.html">GPLv3</a></p>
        <p>
            <a href="https://github.com/rydnr/bytehot">GitHub</a> ‚Ä¢ 
            <a href="https://github.com/rydnr/bytehot/issues">Issues</a> ‚Ä¢ 
            <a href="https://github.com/rydnr/bytehot/discussions">Discussions</a>
        </p>
    </footer>

    <script>
        // Matrix rain effect (lighter for documentation pages)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        document.querySelector('.matrix-bg').appendChild(canvas);
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const matrix = "BYTEHOT0123456789";
        const drops = [];
        for(let x = 0; x < canvas.width / 15; x++) { drops[x] = 1; }
        function draw() {
            ctx.fillStyle = 'rgba(15, 15, 35, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px Courier New';
            for(let i = 0; i < drops.length; i++) {
                const text = matrix[Math.floor(Math.random() * matrix.length)];
                ctx.fillText(text, i * 15, drops[i] * 15);
                if(drops[i] * 15 > canvas.height && Math.random() > 0.98) { drops[i] = 0; }
                drops[i]++;
            }
        }
        setInterval(draw, 50);
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
    </script>
</body>
</html>
