<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InstanceTracker - ByteHot Documentation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 100%); color: #00ff00; line-height: 1.6; overflow-x: hidden; }
        .matrix-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; opacity: 0.05; }
        .nav-header { position: fixed; top: 0; left: 0; right: 0; background: rgba(15, 15, 35, 0.95); backdrop-filter: blur(10px); padding: 1rem 2rem; z-index: 1000; border-bottom: 2px solid #00ff00; }
        .nav-links { display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; }
        .nav-link { color: #00ff00; text-decoration: none; padding: 0.4rem 0.8rem; border: 1px solid #00ff00; border-radius: 4px; transition: all 0.3s ease; font-weight: bold; font-size: 0.9rem; }
        .nav-link:hover { background: #00ff00; color: #0f0f23; box-shadow: 0 0 15px #00ff00; transform: translateY(-2px); }
        .content { margin-top: 100px; padding: 2rem; max-width: 1200px; margin-left: auto; margin-right: auto; }
        .doc-container { background: rgba(26, 26, 58, 0.8); border: 1px solid #00ff00; border-radius: 12px; padding: 3rem; margin: 2rem 0; }
        .doc-container h1 { color: #00cccc; font-size: 2.5rem; margin: 0 0 2rem 0; text-shadow: 0 0 15px #00cccc; text-align: center; }
        .doc-container h2 { color: #00ff00; font-size: 1.8rem; margin: 2rem 0 1rem 0; border-left: 4px solid #00ff00; padding-left: 1rem; text-shadow: 0 0 10px #00ff00; }
        .doc-container h3 { color: #00cccc; font-size: 1.4rem; margin: 1.5rem 0 1rem 0; }
        .doc-container h4, .doc-container h5, .doc-container h6 { color: #ffffff; margin: 1rem 0 0.5rem 0; }
        .doc-container p { color: #ffffff; margin: 1rem 0; line-height: 1.8; }
        .doc-container ul, .doc-container ol { color: #ffffff; margin: 1rem 0; padding-left: 2rem; }
        .doc-container li { margin: 0.5rem 0; line-height: 1.6; }
        .doc-container code { background: rgba(0, 0, 0, 0.5); color: #00ff00; padding: 0.2rem 0.4rem; border-radius: 4px; font-family: 'Courier New', monospace; border: 1px solid rgba(0, 255, 0, 0.3); }
        .doc-container pre { background: rgba(0, 0, 0, 0.8); border: 1px solid #00ff00; border-radius: 8px; padding: 1.5rem; overflow-x: auto; margin: 1.5rem 0; }
        .doc-container pre code { background: none; padding: 0; border: none; }
        .doc-container a { color: #00cccc; text-decoration: none; border-bottom: 1px dotted #00cccc; transition: all 0.3s ease; }
        .doc-container a:hover { color: #ffffff; border-bottom-color: #ffffff; text-shadow: 0 0 5px #00cccc; }
        .doc-container table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; background: rgba(0, 0, 0, 0.3); }
        .doc-container th, .doc-container td { border: 1px solid #00ff00; padding: 0.8rem; text-align: left; }
        .doc-container th { background: rgba(0, 255, 0, 0.1); color: #00ff00; font-weight: bold; }
        .doc-container td { color: #ffffff; }
        .doc-container blockquote { border-left: 4px solid #00cccc; padding-left: 1.5rem; margin: 1.5rem 0; color: #00cccc; font-style: italic; background: rgba(0, 204, 204, 0.05); padding: 1rem 1rem 1rem 1.5rem; border-radius: 0 8px 8px 0; }
        .footer { background: rgba(0, 0, 0, 0.8); padding: 2rem; text-align: center; border-top: 2px solid #00ff00; margin-top: 4rem; }
        .footer a { color: #00ff00; text-decoration: none; }
        .footer a:hover { text-shadow: 0 0 10px #00ff00; }
        @media (max-width: 768px) { .nav-links { gap: 0.8rem; } .nav-link { padding: 0.3rem 0.6rem; font-size: 0.8rem; } .content { padding: 1rem; } .doc-container { padding: 2rem; } .doc-container h1 { font-size: 2rem; } }
    </style>
</head>
<body>
    <div class="matrix-bg"></div>
    
    <nav class="nav-header">
        <div class="nav-links">
            <a href="index.html" class="nav-link">Home</a>
            <a href="story.html" class="nav-link">üìñ Story</a>
            <a href="GETTING_STARTED.html" class="nav-link">üöÄ Getting Started</a>
            <a href="implementation.html" class="nav-link">‚öôÔ∏è Implementation</a>
            <a href="literate-docs.html" class="nav-link">üìö Literate Docs</a>
            <a href="journal.html" class="nav-link">üìî Journal</a>
            <a href="javadocs/" class="nav-link">JavaDocs</a>
            <a href="https://github.com/rydnr/bytehot" class="nav-link">GitHub</a>
        </div>
    </nav>

    <div class="content">
        <div class="doc-container">
<h1 id="overview">Overview</h1>
<p>The <code class="verbatim">InstanceTracker</code> class provides
thread-safe tracking of class instances using weak references. It
enables discovery and counting of existing instances without preventing
garbage collection, which is crucial for hot-swap operations that need
to update existing objects.</p>
<h2 id="key-responsibilities">Key Responsibilities</h2>
<ul>
<li>Track existing instances of classes using weak references</li>
<li>Enable/disable tracking for specific classes</li>
<li>Provide instance discovery and counting capabilities</li>
<li>Maintain thread-safety for concurrent access</li>
<li>Prevent memory leaks through garbage collection compatibility</li>
</ul>
<h2 id="design-patterns">Design Patterns</h2>
<ul>
<li><strong>Observer Pattern</strong>: For instance lifecycle
tracking</li>
<li><strong>Weak Reference Pattern</strong>: For garbage collection
compatibility</li>
<li><strong>Registry Pattern</strong>: For centralized instance
management</li>
</ul>
<h1 id="class-declaration-and-imports">Class Declaration and
Imports</h1>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/InstanceTracker.java"><code>/*
                        ByteHot

    Copyright (C) 2025-today  rydnr@acm-sl.org

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public v3
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Thanks to ACM S.L. for distributing this library under the GPLv3 license.
    Contact info: jose.sanleandro@acm-sl.com

 ******************************************************************************
 *
 * Filename: InstanceTracker.java
 *
 * Author: Claude Code
 *
 * Class name: InstanceTracker
 *
 * Responsibilities:
 *   - Track existing instances of classes using weak references
 *   - Enable/disable tracking for specific classes
 *   - Provide instance discovery and counting capabilities
 *
 * Collaborators:
 *   - WeakReference: For tracking instances without preventing garbage collection
 *   - ConcurrentHashMap: For thread-safe tracking
 */
package org.acmsl.bytehot.domain;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
</code></pre>
<h1 id="class-definition-and-state-management">Class Definition and
State Management</h1>
<p>The <code class="verbatim">InstanceTracker</code> uses thread-safe
collections and weak references to track instances without affecting
garbage collection.</p>
<p>/**</p>
<ul>
<li>Tracks existing instances of classes using weak references</li>
<li>@author Claude Code</li>
<li>@since 2025-06-17</li>
</ul>
<p>*/ public class InstanceTracker {</p>
<p>/**</p>
<ul>
<li>Registry of tracked instances per class using weak references</li>
</ul>
<p>*/ private final ConcurrentHashMap&lt;Class&lt;?&gt;,
List&lt;WeakReference&lt;Object&gt;&gt;&gt; instanceRegistry;</p>
<p>/**</p>
<ul>
<li>Set of classes that have tracking enabled</li>
</ul>
<p>*/ private final Set&lt;Class&lt;?&gt;&gt; trackedClasses;</p>
<p>/**</p>
<ul>
<li>Creates a new instance tracker</li>
</ul>
<p>*/ public InstanceTracker() { this.instanceRegistry = new
ConcurrentHashMap&lt;&gt;(); this.trackedClasses =
Collections.synchronizedSet(new HashSet&lt;&gt;()); }</p>
<h1 id="tracking-control-methods">Tracking Control Methods</h1>
<h2 id="global-tracking-status">Global Tracking Status</h2>
<p>Checks if any class tracking is currently enabled.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/InstanceTracker.java"><code>
/**
 * Checks if tracking is enabled globally (any class is being tracked)
 * @return true if any class has tracking enabled
 */
public boolean isTrackingEnabled() {
    return !trackedClasses.isEmpty();
}
</code></pre>
<h2 id="class-specific-tracking-status">Class-Specific Tracking
Status</h2>
<p>Checks if tracking is enabled for a specific class.</p>
<p>/**</p>
<ul>
<li>Checks if tracking is enabled for a specific class</li>
<li>@param clazz the class to check</li>
<li>@return true if tracking is enabled for the class</li>
</ul>
<p>*/ public boolean isTrackingEnabled(final Class&lt;?&gt; clazz) {
return trackedClasses.contains(clazz); }</p>
<h2 id="enable-tracking">Enable Tracking</h2>
<p>Enables tracking for a specific class and initializes the instance
registry.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/InstanceTracker.java"><code>
/**
 * Enables tracking for a specific class
 * @param clazz the class to enable tracking for
 */
public void enableTracking(final Class&lt;?&gt; clazz) {
    trackedClasses.add(clazz);
    instanceRegistry.putIfAbsent(clazz, Collections.synchronizedList(new ArrayList&lt;&gt;()));
}
</code></pre>
<h2 id="disable-tracking">Disable Tracking</h2>
<p>Disables tracking for a specific class and removes all tracked
instances.</p>
<p>/**</p>
<ul>
<li>Disables tracking for a specific class</li>
<li>@param clazz the class to disable tracking for</li>
</ul>
<p>*/ public void disableTracking(final Class&lt;?&gt; clazz) {
trackedClasses.remove(clazz); instanceRegistry.remove(clazz); }</p>
<h1 id="instance-registration-methods">Instance Registration
Methods</h1>
<h2 id="primary-instance-tracking">Primary Instance Tracking</h2>
<p>Provides a convenient interface for tracking instances.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/InstanceTracker.java"><code>
/**
 * Tracks an instance of a class
 * @param instance the instance to track
 */
public void track(final Object instance) {
    trackInstance(instance);
}
</code></pre>
<h2 id="core-instance-tracking">Core Instance Tracking</h2>
<p>The main method for registering instances for tracking using weak
references.</p>
<p>/**</p>
<ul>
<li>Tracks an instance of a class</li>
<li>@param instance the instance to track</li>
</ul>
<p>*/ public void trackInstance(final Object instance) { if (instance ==
null) { return; }</p>
<p>final Class&lt;?&gt; clazz = instance.getClass(); if
(isTrackingEnabled(clazz)) { final
List&lt;WeakReference&lt;Object&gt;&gt; instances =
instanceRegistry.get(clazz); if (instances != null) { instances.add(new
WeakReference&lt;&gt;(instance)); } } }</p>
<h1 id="instance-discovery-methods">Instance Discovery Methods</h1>
<h2 id="find-instances-by-class">Find Instances by Class</h2>
<p>Discovers all currently tracked instances of a specific class.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/InstanceTracker.java"><code>
/**
 * Finds all tracked instances of a specific class
 * @param clazz the class to find instances for
 * @return set of tracked instances (may be empty but never null)
 */
public Set&lt;Object&gt; findInstances(final Class&lt;?&gt; clazz) {
    if (!isTrackingEnabled(clazz)) {
        return Collections.emptySet();
    }

    final List&lt;WeakReference&lt;Object&gt;&gt; weakRefs = instanceRegistry.get(clazz);
    if (weakRefs == null) {
        return Collections.emptySet();
    }

    final Set&lt;Object&gt; instances = new HashSet&lt;&gt;();
    cleanupWeakReferences(weakRefs, instances);

    return instances;
}
</code></pre>
<h1 id="instance-counting-methods">Instance Counting Methods</h1>
<h2 id="count-by-class-object">Count by Class Object</h2>
<p>Counts the number of tracked instances for a specific class.</p>
<p>/**</p>
<ul>
<li>Counts tracked instances of a specific class</li>
<li>@param clazz the class to count instances for</li>
<li>@return number of tracked instances</li>
</ul>
<p>*/ public int countInstances(final Class&lt;?&gt; clazz) { return
findInstances(clazz).size(); }</p>
<h2 id="count-by-class-name">Count by Class Name</h2>
<p>Provides counting capability using class names for integration with
other components.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/InstanceTracker.java"><code>
/**
 * Gets the number of tracked instances for a specific class name
 * @param className the fully qualified class name
 * @return number of tracked instances
 */
public int getInstanceCount(final String className) {
    try {
        final Class&lt;?&gt; clazz = Class.forName(className);
        return countInstances(clazz);
    } catch (ClassNotFoundException e) {
        return 0;
    }
}
</code></pre>
<h1 id="memory-management-methods">Memory Management Methods</h1>
<h2 id="public-cleanup-interface">Public Cleanup Interface</h2>
<p>Provides a public interface for triggering cleanup of dead weak
references.</p>
<p>/**</p>
<ul>
<li>Cleans up weak references that have been garbage collected</li>
</ul>
<p>*/ public void cleanupWeakReferences() { for (final
List&lt;WeakReference&lt;Object&gt;&gt; weakRefs :
instanceRegistry.values()) { cleanupWeakReferences(weakRefs, null); }
}</p>
<h2 id="internal-cleanup-implementation">Internal Cleanup
Implementation</h2>
<p>The core cleanup method that removes dead references and optionally
collects live instances.</p>
<pre class="java"
data-tangle="../bytehot/src/main/java/org/acmsl/bytehot/domain/InstanceTracker.java"><code>
    /**
     * Cleans up weak references and optionally collects live instances
     * @param weakRefs the list of weak references to clean
     * @param liveInstances optional set to collect live instances into
     */
    protected void cleanupWeakReferences(final List&lt;WeakReference&lt;Object&gt;&gt; weakRefs, final Set&lt;Object&gt; liveInstances) {
        synchronized (weakRefs) {
            final List&lt;WeakReference&lt;Object&gt;&gt; toRemove = new ArrayList&lt;&gt;();

            for (final WeakReference&lt;Object&gt; weakRef : weakRefs) {
                final Object instance = weakRef.get();
                if (instance == null) {
                    // Instance has been garbage collected
                    toRemove.add(weakRef);
                } else if (liveInstances != null) {
                    // Collect live instance
                    liveInstances.add(instance);
                }
            }

            // Remove dead references
            weakRefs.removeAll(toRemove);
        }
    }
}
</code></pre>
<h1 id="usage-examples">Usage Examples</h1>
<h2 id="basic-instance-tracking">Basic Instance Tracking</h2>
<p>InstanceTracker tracker = new InstanceTracker();</p>
<p>// Enable tracking for a specific class
tracker.enableTracking(MyService.class);</p>
<p>// Track instances as they are created MyService service1 = new
MyService(); MyService service2 = new MyService();
tracker.track(service1); tracker.track(service2);</p>
<p>// Count tracked instances int count =
tracker.countInstances(MyService.class); System.out.println("Tracked
instances: " + count);</p>
<p>// Find all instances Set&lt;Object&gt; instances =
tracker.findInstances(MyService.class); for (Object instance :
instances) { // Process each tracked instance System.out.println("Found
instance: " + instance); }</p>
<h2 id="integration-with-hot-swap-operations">Integration with Hot-Swap
Operations</h2>
<pre class="java"><code>// Before performing hot-swap, find all instances that need updating
Set&lt;Object&gt; instancesToUpdate = tracker.findInstances(targetClass);

// Perform hot-swap operation
redefineClass(targetClass, newBytecode);

// Update all tracked instances
for (Object instance : instancesToUpdate) {
    updateInstanceAfterRedefinition(instance);
}
</code></pre>
<h2 id="cleanup-and-memory-management">Cleanup and Memory
Management</h2>
<p>// Periodic cleanup to remove dead references Timer cleanupTimer =
new Timer(); cleanupTimer.scheduleAtFixedRate(new TimerTask() {
@Override public void run() { tracker.cleanupWeakReferences(); } }, 0,
60000); // Cleanup every minute</p>
<h2 id="dynamic-tracking-control">Dynamic Tracking Control</h2>
<pre class="java"><code>// Enable tracking when needed
if (needsInstanceTracking(someClass)) {
    tracker.enableTracking(someClass);
}

// Disable tracking to save resources
if (!needsInstanceTracking(someClass)) {
    tracker.disableTracking(someClass);
}

// Check if any tracking is active
if (tracker.isTrackingEnabled()) {
    System.out.println(&quot;Instance tracking is active&quot;);
}
</code></pre>
<h1 id="architecture-notes">Architecture Notes</h1>
<h2 id="thread-safety-design">Thread Safety Design</h2>
<ul>
<li><code class="verbatim">ConcurrentHashMap</code> for thread-safe
class-to-instances mapping</li>
<li>Synchronized <code class="verbatim">Set</code> for tracked classes
management</li>
<li>Synchronized lists for weak reference collections</li>
<li>Atomic operations for consistent state updates</li>
</ul>
<h2 id="memory-management-strategy">Memory Management Strategy</h2>
<ul>
<li>Weak references prevent memory leaks by allowing garbage
collection</li>
<li>Automatic cleanup of dead references during instance discovery</li>
<li>Manual cleanup methods for proactive memory management</li>
<li>No strong references maintained to tracked instances</li>
</ul>
<h2 id="performance-considerations">Performance Considerations</h2>
<ul>
<li>Lazy cleanup during normal operations to minimize overhead</li>
<li>Efficient concurrent data structures for high-performance
access</li>
<li>Optional manual cleanup for applications with strict memory
requirements</li>
<li>Minimal synchronization overhead through careful lock design</li>
</ul>
<h2 id="integration-points">Integration Points</h2>
<ul>
<li>Class name-based access for integration with reflection-based
systems</li>
<li>Flexible enable/disable tracking for dynamic resource
management</li>
<li>Compatible with dependency injection frameworks</li>
<li>Suitable for integration with JVM agents and instrumentation</li>
</ul>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 ByteHot Project. Licensed under <a href="https://www.gnu.org/licenses/gpl-3.0.html">GPLv3</a></p>
        <p>
            <a href="https://github.com/rydnr/bytehot">GitHub</a> ‚Ä¢ 
            <a href="https://github.com/rydnr/bytehot/issues">Issues</a> ‚Ä¢ 
            <a href="https://github.com/rydnr/bytehot/discussions">Discussions</a>
        </p>
    </footer>

    <script>
        // Matrix rain effect (lighter for documentation pages)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        document.querySelector('.matrix-bg').appendChild(canvas);
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const matrix = "BYTEHOT0123456789";
        const drops = [];
        for(let x = 0; x < canvas.width / 15; x++) { drops[x] = 1; }
        function draw() {
            ctx.fillStyle = 'rgba(15, 15, 35, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px Courier New';
            for(let i = 0; i < drops.length; i++) {
                const text = matrix[Math.floor(Math.random() * matrix.length)];
                ctx.fillText(text, i * 15, drops[i] * 15);
                if(drops[i] * 15 > canvas.height && Math.random() > 0.98) { drops[i] = 0; }
                drops[i]++;
            }
        }
        setInterval(draw, 50);
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
    </script>
</body>
</html>
