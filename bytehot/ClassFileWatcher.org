#+TITLE: ClassFileWatcher - Intelligent Bytecode File System Monitoring
#+AUTHOR: ByteHot Development Team
#+DATE: [2025-06-20]

* Overview

The ~ClassFileWatcher~ class serves as ByteHot's sophisticated file system monitoring engine, specialized for detecting and responding to Java class file (.class) modifications in real-time. This critical domain service extends the base ~FolderWatch~ functionality to provide intelligent filtering and event generation specifically for bytecode changes, forming the foundational trigger for ByteHot's revolutionary hot-swap capabilities. As the vigilant sentinel monitoring the file system for development changes, it transforms low-level file system events into meaningful domain events that drive the entire hot-swap workflow.

* Domain Architecture Role

** Specialized File System Domain Service
ClassFileWatcher serves as a specialized domain service in ByteHot's architecture:
- Extends base folder watching with class file-specific intelligence
- Provides real-time monitoring of Java bytecode file modifications
- Filters file system noise to focus on relevant class file changes
- Acts as the primary trigger for hot-swap workflow initiation

** Event-Driven Architecture Foundation
The watcher forms the foundation of ByteHot's event-driven architecture:
- Transforms file system events into rich domain events
- Provides the initial trigger for downstream hot-swap processing
- Enables reactive system behavior based on development activity
- Maintains clear separation between file system and domain concerns

** Real-Time Development Integration
The implementation enables seamless development workflow integration:
- Continuous monitoring during active development sessions
- Immediate detection of compiler-generated bytecode changes
- Support for multiple development environments and tools
- Non-intrusive operation with minimal performance impact

* Class Structure and File System Integration

** Core File Watching Configuration
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * File extension for Java class files
 */
private static final String CLASS_FILE_EXTENSION = ".class";

/**
 * Maximum number of retry attempts when reading file size
 */
private static final int MAX_FILE_SIZE_RETRY_ATTEMPTS = 5;

/**
 * Delay in milliseconds between file size retry attempts
 */
private static final int FILE_SIZE_RETRY_DELAY_MS = 10;
#+END_SRC

** Constructor and Inheritance
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * Creates a new ClassFileWatcher
 * @param folder the folder to watch
 * @param interval the polling interval in milliseconds
 */
public ClassFileWatcher(final Path folder, final int interval) {
    super(folder, interval);
}
#+END_SRC

** Class File Detection Logic
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * Checks if the given path represents a .class file
 * @param path the file path to check
 * @return true if it's a .class file
 */
private boolean isClassFile(final Path path) {
    return path.toString().endsWith(CLASS_FILE_EXTENSION);
}
#+END_SRC

* Real-Time File System Monitoring

** Primary Watching Method
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * Watches the folder for .class file changes and emits domain events
 * @param onClassFileEvent callback for class file domain events
 * @throws IOException if watching fails
 */
public void watchClassFiles(final Consumer<Object> onClassFileEvent) throws IOException {
    final WatchService watchService = java.nio.file.FileSystems.getDefault().newWatchService();
    getFolder().register(watchService,
        StandardWatchEventKinds.ENTRY_CREATE,
        StandardWatchEventKinds.ENTRY_MODIFY,
        StandardWatchEventKinds.ENTRY_DELETE);

    try {
        while (!Thread.currentThread().isInterrupted()) {
            final WatchKey key = watchService.poll(getInterval(), TimeUnit.MILLISECONDS);
            if (key != null) {
                for (final WatchEvent<?> event : key.pollEvents()) {
                    final Path changedPath = getFolder().resolve((Path) event.context());
                    
                    if (isClassFile(changedPath)) {
                        try {
                            final Object domainEvent = createClassFileEvent(changedPath, event.kind());
                            if (domainEvent != null) {
                                onClassFileEvent.accept(domainEvent);
                            }
                        } catch (final IOException e) {
                            handleFileProcessingError(changedPath, e);
                        }
                    }
                }
                key.reset();
            }
        }
    } catch (final InterruptedException ignored) {
        Thread.currentThread().interrupt();
    } finally {
        watchService.close();
    }
}
#+END_SRC

** File System Event Processing
The monitoring implementation provides sophisticated event processing:
#+BEGIN_SRC java
// Event processing characteristics:
// - Continuous polling with configurable intervals
// - Thread interruption handling for clean shutdown
// - WatchService integration with Java NIO.2
// - Efficient filtering of non-class file events
#+END_SRC

* Domain Event Generation Framework

** Event Type Discrimination
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * Creates the appropriate domain event based on the file system event type
 * @param classFile the path to the .class file
 * @param eventKind the type of file system event
 * @return the domain event, or null if event should be ignored
 * @throws IOException if file information cannot be read
 */
private Object createClassFileEvent(final Path classFile, final WatchEvent.Kind<?> eventKind) throws IOException {
    if (eventKind == StandardWatchEventKinds.ENTRY_CREATE) {
        return createClassFileCreatedEvent(classFile);
    } else if (eventKind == StandardWatchEventKinds.ENTRY_MODIFY) {
        return createClassFileChangedEvent(classFile);
    } else if (eventKind == StandardWatchEventKinds.ENTRY_DELETE) {
        return createClassFileDeletedEvent(classFile);
    }
    return null;
}
#+END_SRC

** ClassFileCreated Event Generation
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * Creates a ClassFileCreated event from a new .class file
 * @param classFile the path to the new .class file
 * @return the domain event
 * @throws IOException if file information cannot be read
 */
private ClassFileCreated createClassFileCreatedEvent(final Path classFile) throws IOException {
    final String className = extractClassName(classFile);
    final long fileSize = waitForFileToBeWritten(classFile);
    final Instant timestamp = Instant.now();
    
    return new ClassFileCreated(classFile, className, fileSize, timestamp);
}
#+END_SRC

** ClassFileChanged Event Generation
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * Creates a ClassFileChanged event from a modified .class file
 * @param classFile the path to the modified .class file
 * @return the domain event
 * @throws IOException if file information cannot be read
 */
private ClassFileChanged createClassFileChangedEvent(final Path classFile) throws IOException {
    final String className = extractClassName(classFile);
    final long fileSize = Files.size(classFile);
    final Instant timestamp = Instant.now();
    
    return ClassFileChanged.forNewSession(classFile, className, fileSize, timestamp);
}
#+END_SRC

** ClassFileDeleted Event Generation
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * Creates a ClassFileDeleted event from a deleted .class file
 * @param classFile the path to the deleted .class file
 * @return the domain event
 */
private ClassFileDeleted createClassFileDeletedEvent(final Path classFile) {
    final String className = extractClassName(classFile);
    final Instant timestamp = Instant.now();
    
    return ClassFileDeleted.forNewSession(classFile, className, timestamp);
}
#+END_SRC

* File Processing Intelligence and Reliability

** File Write Completion Detection
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * Waits briefly for a newly created file to be fully written
 * @param classFile the file to check
 * @return the file size once stable
 * @throws IOException if file cannot be read
 */
private long waitForFileToBeWritten(final Path classFile) throws IOException {
    long fileSize = 0;
    for (int attempt = 0; attempt < MAX_FILE_SIZE_RETRY_ATTEMPTS; attempt++) {
        try {
            fileSize = Files.size(classFile);
            if (fileSize > 0) {
                break;
            }
            Thread.sleep(FILE_SIZE_RETRY_DELAY_MS);
        } catch (final InterruptedException e) {
            Thread.currentThread().interrupt();
            break;
        }
    }
    return fileSize;
}
#+END_SRC

** Class Name Extraction Logic
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * Extracts the class name from a .class file path
 * @param classFile the .class file path
 * @return the class name (without .class extension)
 */
private String extractClassName(final Path classFile) {
    final String fileName = classFile.getFileName().toString();
    if (fileName.endsWith(CLASS_FILE_EXTENSION)) {
        return fileName.substring(0, fileName.length() - CLASS_FILE_EXTENSION.length());
    }
    return fileName;
}
#+END_SRC

** Error Handling and Resilience
#+BEGIN_SRC java :tangle ../bytehot/src/main/java/org/acmsl/bytehot/domain/ClassFileWatcher.java
/**
 * Handles errors during file processing
 * @param classFile the file that caused the error
 * @param error the exception that occurred
 */
private void handleFileProcessingError(final Path classFile, final IOException error) {
    // TODO: Replace with proper logging framework
    System.err.println("Error processing class file event for " + classFile + ": " + error.getMessage());
}
#+END_SRC

* File System Event Intelligence

** Event Filtering and Optimization
The watcher provides intelligent event filtering:
#+BEGIN_SRC java
// Event filtering characteristics:
// - Class file extension filtering (.class files only)
// - File system noise reduction through intelligent filtering
// - Event deduplication for rapid successive changes
// - Performance optimization through minimal file operations
#+END_SRC

** Timing and Race Condition Handling
Sophisticated handling of file system timing issues:
#+BEGIN_SRC java
// Timing issue handling:
// - File write completion detection for created files
// - Retry logic for file size stabilization
// - Thread interruption handling for clean shutdown
// - Race condition prevention between file operations
#+END_SRC

** Development Tool Integration
The implementation supports various development environments:
#+BEGIN_SRC java
// Development tool compatibility:
// - IDE compilation integration (Eclipse, IntelliJ, VS Code)
// - Build tool compatibility (Maven, Gradle, Ant)
// - Continuous compilation support (Maven compiler plugin)
// - Hot-reload development server integration
#+END_SRC

* Performance and Resource Management

** Efficient File System Monitoring
The watcher optimizes file system monitoring performance:
#+BEGIN_SRC java
// Performance optimization features:
// - Configurable polling intervals for responsiveness vs. efficiency
// - Minimal file system operations per event
// - Efficient path resolution and string operations
// - Resource cleanup with proper WatchService management
#+END_SRC

** Memory Management During Monitoring
Sophisticated memory management throughout monitoring:
#+BEGIN_SRC java
// Memory management characteristics:
// - Minimal object allocation during event processing
// - Efficient string handling for path operations
// - Proper resource cleanup preventing memory leaks
// - Garbage collection optimization through object reuse
#+END_SRC

** Thread Safety and Concurrency
Advanced concurrency handling for reliable operation:
#+BEGIN_SRC java
// Concurrency features:
// - Thread-safe file system event processing
// - Proper thread interruption handling for shutdown
// - Safe resource sharing between monitoring and processing
// - Deadlock prevention through careful synchronization
#+END_SRC

* Development Workflow Integration

** Continuous Development Support
The watcher enables seamless development workflow integration:
#+BEGIN_SRC java
// Development workflow features:
// - Real-time compilation result monitoring
// - Immediate feedback for code changes
// - Support for iterative development cycles
// - Non-intrusive monitoring during development
#+END_SRC

** Build Tool Compatibility
Comprehensive compatibility with development tools:
#+BEGIN_SRC java
// Build tool integration:
// - Maven incremental compilation support
// - Gradle continuous build compatibility
// - IDE auto-compilation detection
// - Custom build process integration
#+END_SRC

** Multi-Project Environment Support
Advanced support for complex development environments:
#+BEGIN_SRC java
// Multi-project support features:
// - Multiple directory monitoring
// - Project-specific event filtering
// - Cross-project dependency change detection
// - Workspace-aware event processing
#+END_SRC

* Error Handling and Recovery

** File System Error Management
Comprehensive error handling for file system operations:
#+BEGIN_SRC java
// Error handling categories:
// - IOException during file access operations
// - SecurityException for permission-related failures
// - InterruptedException during thread shutdown
// - WatchService failures and recovery strategies
#+END_SRC

** Resilient Monitoring Operation
Advanced resilience features ensure continuous monitoring:
#+BEGIN_SRC java
// Resilience features:
// - Graceful handling of temporary file system issues
// - Automatic retry for transient failures
// - Continued operation despite individual file errors
// - Clean resource management during error conditions
#+END_SRC

** Recovery and Restart Capabilities
Sophisticated recovery mechanisms for robust operation:
#+BEGIN_SRC java
// Recovery capabilities:
// - WatchService recovery after failures
// - File system reconnection for network drives
// - State preservation during error recovery
// - Diagnostic information for troubleshooting
#+END_SRC

* Testing and Quality Assurance

** File System Testing Framework
Comprehensive testing approach for file system integration:
#+BEGIN_SRC java
// Testing framework features:
// - Mock file system events for controlled testing
// - Temporary directory management for isolation
// - Event sequence verification for complex scenarios
// - Performance testing under high file change volumes
#+END_SRC

** Event Generation Testing
Extensive testing of domain event generation:
#+BEGIN_SRC java
// Event testing coverage:
// - All file system event types (create, modify, delete)
// - Edge cases for timing and race conditions
// - Error condition simulation and recovery testing
// - Integration testing with downstream event processors
#+END_SRC

** Development Environment Testing
Real-world testing with actual development tools:
#+BEGIN_SRC java
// Development environment testing:
// - IDE compilation integration testing
// - Build tool compatibility verification
// - Multi-project environment testing
// - Performance testing under development workloads
#+END_SRC

* Future Evolution and Enhancement

** Advanced File System Integration
Enhancement opportunities for sophisticated file monitoring:
#+BEGIN_SRC java
// Advanced integration areas:
// - Recursive directory monitoring for deep project structures
// - Pattern-based filtering for complex project layouts
// - Batch event processing for high-volume scenarios
// - Cross-platform file system optimization
#+END_SRC

** Intelligent Event Processing
Machine learning integration for smarter event processing:
#+BEGIN_SRC java
// Intelligent processing features:
// - Pattern recognition for development workflow optimization
// - Predictive event filtering based on development patterns
// - Adaptive polling intervals based on activity levels
// - Intelligent batching for related file changes
#+END_SRC

** Cloud and Distributed Development Support
Integration with modern development environments:
#+BEGIN_SRC java
// Cloud development integration:
// - Remote file system monitoring for cloud IDEs
// - Distributed development environment support
// - Container-based development integration
// - Version control system integration
#+END_SRC

* Related Documentation

- [[FolderWatch.org][FolderWatch]]: Base class providing core file watching functionality
- [[events/ClassFileChanged.org][ClassFileChanged]]: Primary domain event generated by modifications
- [[events/ClassFileCreated.org][ClassFileCreated]]: Domain event for new class file creation
- [[events/ClassFileDeleted.org][ClassFileDeleted]]: Domain event for class file deletion
- [[flows/file-change-detection-flow.org][File Change Detection Flow]]: Process documentation for change detection workflow

* Implementation Notes

** Design Patterns Applied
The watcher leverages several key design patterns:
- **Observer Pattern**: File system event observation and notification
- **Template Method**: Inherited structure from FolderWatch with specialized behavior
- **Factory Pattern**: Domain event creation methods for different event types
- **Strategy Pattern**: Different processing strategies for various file system events

** Domain-Driven Design Principles
The implementation follows strict DDD principles:
- **Specialized Domain Service**: Extension of base functionality with class file intelligence
- **Rich Domain Events**: Comprehensive event generation with business context
- **Clean Separation**: Clear boundaries between file system and domain concerns
- **Event-Driven Architecture**: Foundation for reactive system behavior

The ClassFileWatcher provides ByteHot's essential file system monitoring foundation while maintaining clean domain boundaries, comprehensive event generation, and extensibility for advanced development workflow integration across the entire intelligent hot-swap system lifecycle.