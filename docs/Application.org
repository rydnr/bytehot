#+TITLE: Application Interface - Hexagonal Architecture Foundation
#+AUTHOR: ByteHot Development Team
#+DATE: 2025-06-25

* Overview

The =Application= interface serves as the cornerstone of ByteHot's hexagonal architecture, defining the contract for the application layer that orchestrates business logic without being contaminated by infrastructure concerns.

* Architecture Role

** Hexagonal Architecture Position
The =Application= interface sits at the boundary between the domain and infrastructure layers, providing a clean abstraction that enables:

- Complete separation of business logic from technical concerns
- Infrastructure-agnostic event processing
- Testable application workflows through event-driven design
- Dynamic adapter discovery and injection

** Event-Driven Processing
The interface defines a single, powerful method that processes any domain event and returns appropriate response events:

#+BEGIN_SRC java
List<? extends DomainResponseEvent<?>> accept(final DomainEvent event);
#+END_SRC

This generic approach eliminates the need for multiple parameterized interfaces while maintaining type safety through internal dispatching.

* Implementation Patterns

** Internal Event Dispatching
Implementing classes typically use pattern matching or visitor patterns to handle different event types:

#+BEGIN_SRC java
public List<? extends DomainResponseEvent<?>> accept(final DomainEvent event) {
    return switch (event) {
        case ClassFileChanged cfc -> handleClassFileChanged(cfc);
        case BytecodeValidated bv -> handleBytecodeValidated(bv);
        // ... other event types
        default -> handleUnknownEvent(event);
    };
}
#+END_SRC

** Response Event Generation
Each event handler returns a list of response events, enabling:
- Event chains and workflows
- Notifications to multiple subscribers  
- Audit trail generation
- Error handling through events

* Benefits

** Architectural Purity
- Domain logic remains free of infrastructure dependencies
- Infrastructure adapters interact through well-defined contracts
- Testing becomes straightforward with event-based inputs/outputs

** Flexibility
- New event types can be added without interface changes
- Multiple implementations can coexist for different contexts
- Dynamic behavior modification through event routing

** Maintainability
- Clear separation of concerns
- Predictable event flow patterns
- Centralized application logic coordination

* ByteHot Integration

In ByteHot's architecture, the =Application= interface enables:

** Hot-Swap Coordination
The application layer orchestrates the complete hot-swap workflow by processing events like:
- =ClassFileChanged= → triggers validation pipeline
- =BytecodeValidated= → initiates class redefinition
- =ClassRedefined= → triggers instance updates

** Framework Integration
Infrastructure adapters discover and invoke application implementations without tight coupling, enabling:
- Spring integration through ApplicationContext discovery
- CDI integration through BeanManager lookup
- Direct instantiation for simple scenarios

** Error Handling
Application implementations coordinate error handling by:
- Processing error events from infrastructure
- Generating appropriate recovery responses
- Maintaining system consistency through event sequencing

* Related Components

- =DomainEvent= - Base interface for all events processed
- =DomainResponseEvent= - Response events generated by applications
- =Port= - Infrastructure abstractions used by applications
- =PortResolver= - Mechanism for discovering infrastructure implementations

This interface represents the evolution of ByteHot's architecture toward maximum flexibility while maintaining the principles of hexagonal design and event-driven processing.