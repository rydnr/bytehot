<!DOCTYPE html>
<html>
<head>
    <title>framework-integration-flow - ByteHot Documentation</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
<h1 id="overview">Overview</h1>
<p>This flow documents how ByteHot integrates with dependency injection
frameworks (Spring, CDI, Guice) to provide enhanced instance management
during hot-swap operations. Framework integration enables more
sophisticated instance update strategies beyond basic reflection.</p>
<h2 id="flow-trigger">Flow Trigger</h2>
<ul>
<li><strong><strong>Starting Event</strong></strong>: Framework-managed
class redefinition or <code class="verbatim">FrameworkIntegration</code>
detection</li>
<li><strong><strong>Ending Event</strong></strong>: Framework-specific
<code class="verbatim">InstancesUpdated</code> with enhanced
capabilities</li>
<li><strong><strong>Duration</strong></strong>: 50-300ms depending on
framework complexity</li>
<li><strong><strong>Criticality</strong></strong>: Medium - Enhances
hot-swap capabilities but not required</li>
</ul>
<h1 id="flow-participants">Flow Participants</h1>
<h2 id="primary-actors">Primary Actors</h2>
<ul>
<li><code class="verbatim">FrameworkIntegration</code> (Domain):
Framework detection and adaptation</li>
<li><code class="verbatim">InstanceUpdater</code> (Domain): Coordinates
framework-aware updates</li>
<li><code class="verbatim">InstanceTracker</code> (Domain): Tracks
framework-managed instances</li>
<li>Framework-specific adapters (Infrastructure): Spring, CDI, Guice
adapters</li>
</ul>
<h2 id="secondary-actors">Secondary Actors</h2>
<ul>
<li><code class="verbatim">StatePreserver</code> (Domain): Enhanced
state management for framework objects</li>
<li>Application contexts and containers from respective frameworks</li>
<li>Proxy management systems</li>
</ul>
<h1 id="framework-detection-and-setup-flow">Framework Detection and
Setup Flow</h1>
<h2 id="phase-1-framework-discovery">Phase 1: Framework Discovery</h2>
<pre><code>[ Agent Startup ] --&gt; [ Classpath Analysis ] --&gt; [ Framework Detection ] --&gt; [ Capability Assessment ]
                             |                          |                         |
                             v                          v                         v
                    [ Annotation Scanning ]    [ Version Detection ]     [ Feature Availability ]
</code></pre>
<p>During agent startup, ByteHot detects available frameworks:</p>
<ol>
<li><strong><strong>Classpath Analysis</strong></strong>: Scan classpath
for framework indicators:
<ul>
<li>Spring: <code
class="verbatim">org.springframework.context.ApplicationContext</code></li>
<li>CDI: <code
class="verbatim">javax.enterprise.context.ApplicationScoped</code></li>
<li>Guice: <code class="verbatim">com.google.inject.Injector</code></li>
</ul></li>
<li><strong><strong>Version Detection</strong></strong>: Determine
framework versions:
<ul>
<li>Extract version information from framework classes</li>
<li>Validate compatibility with ByteHot requirements</li>
<li>Log detected frameworks and versions</li>
</ul></li>
<li><strong><strong>Capability Assessment</strong></strong>: Evaluate
framework-specific capabilities:
<ul>
<li>Proxy support (Spring AOP, CDI proxies)</li>
<li>Factory reset capabilities (dependency recreation)</li>
<li>Event system integration</li>
<li>Custom annotation support</li>
</ul></li>
</ol>
<h2 id="phase-2-framework-adapter-creation">Phase 2: Framework Adapter
Creation</h2>
<pre><code>[ Framework Detection ] --&gt; [ Adapter Selection ] --&gt; [ Adapter Configuration ] --&gt; [ Integration Testing ]
</code></pre>
<p>For each detected framework, create appropriate adapters:</p>
<ol>
<li><strong><strong>Adapter Selection</strong></strong>: Choose
framework-specific adapter implementation</li>
<li><strong><strong>Adapter Configuration</strong></strong>: Configure
adapter with framework details:
<ul>
<li>Framework version compatibility</li>
<li>Available features and limitations</li>
<li>Performance optimization settings</li>
</ul></li>
<li><strong><strong>Integration Testing</strong></strong>: Validate
adapter functionality:
<ul>
<li>Test basic framework interaction</li>
<li>Verify proxy handling capabilities</li>
<li>Validate dependency injection compatibility</li>
</ul></li>
</ol>
<h1 id="framework-aware-instance-updates">Framework-Aware Instance
Updates</h1>
<h2 id="spring-framework-integration-flow">Spring Framework Integration
Flow</h2>
<pre><code>[ ClassRedefinitionSucceeded ] --&gt; [ Spring Detection ] --&gt; [ ApplicationContext Access ]
                                         |                         |
                                         v                         v
                               [ Bean Definition Analysis ] --&gt; [ Bean Recreation ]
                                         |                         |
                                         v                         v
                               [ Proxy Refresh ] --&gt; [ Dependency Re-injection ]
</code></pre>
<p>When updating Spring-managed instances:</p>
<ol>
<li><strong><strong>ApplicationContext Access</strong></strong>: Obtain
reference to Spring ApplicationContext</li>
<li><strong><strong>Bean Definition Analysis</strong></strong>: Analyze
affected beans:
<ul>
<li>Identify bean scope (singleton, prototype, request, session)</li>
<li>Determine dependency graph</li>
<li>Assess proxy configuration (JDK dynamic proxies, CGLIB)</li>
</ul></li>
<li><strong><strong>Update Strategy Selection</strong></strong>: Choose
appropriate Spring-specific strategy:
<ul>
<li><strong><strong>Factory Reset</strong></strong>: Recreate beans
using bean factory</li>
<li><strong><strong>Proxy Refresh</strong></strong>: Update proxy
targets with new class definition</li>
<li><strong><strong>Configuration Refresh</strong></strong>: Reload bean
configurations if needed</li>
</ul></li>
<li><strong><strong>Bean Recreation</strong></strong>: For factory reset
strategy:
<ul>
<li>Destroy existing bean instances</li>
<li>Clear bean factory caches</li>
<li>Recreate beans with new class definition</li>
<li>Re-inject dependencies</li>
</ul></li>
<li><strong><strong>Proxy Refresh</strong></strong>: For proxy refresh
strategy:
<ul>
<li>Update proxy target classes</li>
<li>Refresh proxy method interceptors</li>
<li>Maintain existing proxy references</li>
</ul></li>
</ol>
<h2 id="cdi-framework-integration-flow">CDI Framework Integration
Flow</h2>
<pre><code>[ ClassRedefinitionSucceeded ] --&gt; [ CDI Detection ] --&gt; [ BeanManager Access ]
                                        |                      |
                                        v                      v
                              [ Bean Archive Analysis ] --&gt; [ Contextual Instance Management ]
                                        |                      |
                                        v                      v
                              [ Proxy Update ] --&gt; [ Event Notification ]
</code></pre>
<p>When updating CDI-managed instances:</p>
<ol>
<li><strong><strong>BeanManager Access</strong></strong>: Obtain CDI
BeanManager instance</li>
<li><strong><strong>Bean Archive Analysis</strong></strong>: Analyze CDI
beans:
<ul>
<li>Identify bean scopes (@ApplicationScoped, @RequestScoped, etc.)</li>
<li>Determine qualifier annotations</li>
<li>Assess interceptor and decorator configurations</li>
</ul></li>
<li><strong><strong>Contextual Instance Management</strong></strong>:
Manage CDI contextual instances:
<ul>
<li>Update bean metadata in BeanManager</li>
<li>Refresh contextual instances in active contexts</li>
<li>Handle producer method and field updates</li>
</ul></li>
<li><strong><strong>Proxy Update</strong></strong>: Update CDI proxies:
<ul>
<li>Refresh proxy implementations</li>
<li>Update interceptor chains</li>
<li>Maintain proxy identity consistency</li>
</ul></li>
<li><strong><strong>Event Notification</strong></strong>: Fire CDI
events for instance updates:
<ul>
<li>Custom ByteHot CDI events</li>
<li>Framework lifecycle events</li>
</ul></li>
</ol>
<h2 id="guice-framework-integration-flow">Guice Framework Integration
Flow</h2>
<pre><code>[ ClassRedefinitionSucceeded ] --&gt; [ Guice Detection ] --&gt; [ Injector Access ]
                                         |                      |
                                         v                      v
                               [ Module Analysis ] --&gt; [ Binding Recreation ]
                                         |                      |
                                         v                      v
                               [ Instance Recreation ] --&gt; [ Dependency Graph Update ]
</code></pre>
<p>When updating Guice-managed instances:</p>
<ol>
<li><strong><strong>Injector Access</strong></strong>: Obtain Guice
Injector instance</li>
<li><strong><strong>Module Analysis</strong></strong>: Analyze Guice
modules and bindings:
<ul>
<li>Identify binding configurations for updated classes</li>
<li>Determine singleton vs. non-singleton bindings</li>
<li>Assess provider and factory configurations</li>
</ul></li>
<li><strong><strong>Binding Recreation</strong></strong>: Update Guice
bindings:
<ul>
<li>Create new bindings with updated class definitions</li>
<li>Preserve binding annotations and qualifiers</li>
<li>Update provider implementations if needed</li>
</ul></li>
<li><strong><strong>Instance Recreation</strong></strong>: Recreate
instances through Guice:
<ul>
<li>Clear singleton instance caches</li>
<li>Use Injector to create new instances</li>
<li>Ensure proper dependency injection</li>
</ul></li>
<li><strong><strong>Dependency Graph Update</strong></strong>: Update
dependent instances:
<ul>
<li>Identify objects that depend on updated instances</li>
<li>Recursively update dependency chain</li>
<li>Maintain object identity where possible</li>
</ul></li>
</ol>
<h1 id="enhanced-instance-management">Enhanced Instance Management</h1>
<h2 id="framework-aware-state-preservation">Framework-Aware State
Preservation</h2>
<pre><code>[ State Preservation ] --&gt; [ Framework Context ] --&gt; [ Enhanced Preservation ]
                                  |                        |
                                  v                        v
                         [ Proxy State Handling ] --&gt; [ Framework Metadata ]
</code></pre>
<p>Framework integration enhances state preservation:</p>
<ol>
<li><strong><strong>Framework Context Awareness</strong></strong>:
Understand framework-specific state:
<ul>
<li>Spring: Bean scope and lifecycle state</li>
<li>CDI: Contextual instance state and qualifiers</li>
<li>Guice: Injection metadata and provider state</li>
</ul></li>
<li><strong><strong>Proxy State Handling</strong></strong>: Special
handling for framework proxies:
<ul>
<li>Preserve proxy configuration</li>
<li>Maintain proxy identity</li>
<li>Update proxy targets without changing proxy references</li>
</ul></li>
<li><strong><strong>Enhanced Metadata Preservation</strong></strong>:
Preserve framework-specific metadata:
<ul>
<li>Annotation-driven configuration</li>
<li>Dependency injection metadata</li>
<li>Lifecycle callback information</li>
</ul></li>
</ol>
<h2 id="dependency-chain-management">Dependency Chain Management</h2>
<pre><code>[ Instance Update ] --&gt; [ Dependency Analysis ] --&gt; [ Chain Update ] --&gt; [ Validation ]
</code></pre>
<p>Framework integration enables sophisticated dependency
management:</p>
<ol>
<li><strong><strong>Dependency Analysis</strong></strong>: Map complete
dependency graphs:
<ul>
<li>Direct dependencies (constructor, field, method injection)</li>
<li>Indirect dependencies through providers and factories</li>
<li>Circular dependency detection and handling</li>
</ul></li>
<li><strong><strong>Chain Update Strategy</strong></strong>: Coordinate
updates across dependency chains:
<ul>
<li>Update order determination (dependencies first)</li>
<li>Batch updates for performance</li>
<li>Rollback coordination for failures</li>
</ul></li>
<li><strong><strong>Validation</strong></strong>: Ensure dependency
chain consistency:
<ul>
<li>Verify all dependencies are satisfied</li>
<li>Check for injection point compatibility</li>
<li>Validate framework constraints</li>
</ul></li>
</ol>
<h1 id="framework-specific-optimizations">Framework-Specific
Optimizations</h1>
<h2 id="spring-specific-optimizations">Spring-Specific
Optimizations</h2>
<pre><code>[ Spring Integration ] --&gt; [ AOP Optimization ] --&gt; [ Event Integration ] --&gt; [ Boot Compatibility ]
</code></pre>
<p>Optimizations specific to Spring Framework:</p>
<ol>
<li><strong><strong>AOP Integration</strong></strong>: Enhanced handling
of Spring AOP:
<ul>
<li>Preserve aspect configurations</li>
<li>Update advice implementations</li>
<li>Maintain pointcut definitions</li>
</ul></li>
<li><strong><strong>Event Integration</strong></strong>: Integrate with
Spring's event system:
<ul>
<li>Fire Spring application events for hot-swap operations</li>
<li>Handle event listener updates</li>
<li>Coordinate with Spring Boot actuator</li>
</ul></li>
<li><strong><strong>Boot Compatibility</strong></strong>: Special
handling for Spring Boot:
<ul>
<li>Auto-configuration refresh</li>
<li>Conditional bean updates</li>
<li>DevTools integration</li>
</ul></li>
</ol>
<h2 id="cdi-specific-optimizations">CDI-Specific Optimizations</h2>
<pre><code>[ CDI Integration ] --&gt; [ Context Management ] --&gt; [ Extension Integration ] --&gt; [ Observer Methods ]
</code></pre>
<p>Optimizations specific to CDI:</p>
<ol>
<li><strong><strong>Context Management</strong></strong>: Advanced CDI
context handling:
<ul>
<li>Context lifecycle coordination</li>
<li>Scope-aware instance updates</li>
<li>Custom context support</li>
</ul></li>
<li><strong><strong>Extension Integration</strong></strong>: Work with
CDI extensions:
<ul>
<li>Extension-created beans</li>
<li>Portable extension coordination</li>
<li>Build-time vs. runtime bean discovery</li>
</ul></li>
<li><strong><strong>Observer Method Handling</strong></strong>: Handle
CDI observer methods:
<ul>
<li>Update observer method implementations</li>
<li>Maintain event subscription consistency</li>
<li>Async observer coordination</li>
</ul></li>
</ol>
<h2 id="guice-specific-optimizations">Guice-Specific Optimizations</h2>
<pre><code>[ Guice Integration ] --&gt; [ Module Reloading ] --&gt; [ Provider Updates ] --&gt; [ Scope Management ]
</code></pre>
<p>Optimizations specific to Guice:</p>
<ol>
<li><strong><strong>Module Reloading</strong></strong>: Dynamic module
updates:
<ul>
<li>Module reconfiguration</li>
<li>Binding override handling</li>
<li>Multi-binder coordination</li>
</ul></li>
<li><strong><strong>Provider Updates</strong></strong>: Enhanced
provider support:
<ul>
<li>Provider implementation updates</li>
<li>Factory method updates</li>
<li>Lazy loading coordination</li>
</ul></li>
<li><strong><strong>Scope Management</strong></strong>: Advanced scope
handling:
<ul>
<li>Custom scope implementations</li>
<li>Scope instance lifecycle</li>
<li>Thread-local scope coordination</li>
</ul></li>
</ol>
<h1 id="performance-considerations">Performance Considerations</h1>
<h2 id="framework-detection-optimization">Framework Detection
Optimization</h2>
<pre><code>[ Startup ] --&gt; [ Cached Detection ] --&gt; [ Lazy Loading ] --&gt; [ Performance Monitoring ]
</code></pre>
<p>Optimize framework detection and integration:</p>
<ol>
<li><strong><strong>Cached Detection</strong></strong>: Cache framework
detection results</li>
<li><strong><strong>Lazy Loading</strong></strong>: Load framework
adapters only when needed</li>
<li><strong><strong>Performance Monitoring</strong></strong>: Track
framework integration performance</li>
</ol>
<h2 id="update-strategy-selection">Update Strategy Selection</h2>
<pre><code>[ Class Analysis ] --&gt; [ Framework Capability ] --&gt; [ Strategy Selection ] --&gt; [ Performance Prediction ]
</code></pre>
<p>Choose optimal update strategies based on framework capabilities:</p>
<ol>
<li><strong><strong>Class Analysis</strong></strong>: Analyze class
characteristics for framework compatibility</li>
<li><strong><strong>Framework Capability Mapping</strong></strong>: Map
class features to framework capabilities</li>
<li><strong><strong>Strategy Selection</strong></strong>: Choose most
efficient update strategy</li>
<li><strong><strong>Performance Prediction</strong></strong>: Estimate
update performance before execution</li>
</ol>
<h1 id="error-handling-and-fallback">Error Handling and Fallback</h1>
<h2 id="framework-integration-failures">Framework Integration
Failures</h2>
<pre><code>[ Framework Error ] --&gt; [ Error Classification ] --&gt; [ Fallback Strategy ] --&gt; [ Graceful Degradation ]
</code></pre>
<p>Handle framework integration failures gracefully:</p>
<ol>
<li><strong><strong>Error Classification</strong></strong>: Categorize
framework-related errors:
<ul>
<li>Framework unavailability</li>
<li>Version incompatibility</li>
<li>Permission restrictions</li>
<li>Configuration errors</li>
</ul></li>
<li><strong><strong>Fallback Strategy</strong></strong>: Fall back to
basic reflection-based updates:
<ul>
<li>Disable framework-specific features</li>
<li>Use standard instance update mechanisms</li>
<li>Maintain basic hot-swap functionality</li>
</ul></li>
<li><strong><strong>Graceful Degradation</strong></strong>: Provide
reduced functionality:
<ul>
<li>Log framework integration issues</li>
<li>Continue with limited capabilities</li>
<li>Offer manual configuration options</li>
</ul></li>
</ol>
<h1 id="framework-integration-invariants">Framework Integration
Invariants</h1>
<h2 id="pre-conditions">Pre-conditions</h2>
<ul>
<li>Framework is detected and compatible with ByteHot</li>
<li>Framework adapter is properly initialized</li>
<li>Framework-managed instances are properly tracked</li>
</ul>
<h2 id="post-conditions">Post-conditions</h2>
<ul>
<li>Framework-managed instances reflect new class definitions</li>
<li>Framework metadata and configurations are preserved</li>
<li>Dependency injection continues to work correctly</li>
<li>Framework-specific features remain functional</li>
</ul>
<h2 id="consistency-guarantees">Consistency Guarantees</h2>
<ul>
<li>Framework proxy relationships are maintained</li>
<li>Dependency injection graphs remain consistent</li>
<li>Framework lifecycle methods are properly invoked</li>
<li>Framework-specific annotations and configurations are preserved</li>
</ul>
<h1 id="architecture-benefits">Architecture Benefits</h1>
<h2 id="enhanced-capabilities">Enhanced Capabilities</h2>
<ul>
<li>More sophisticated instance update strategies</li>
<li>Better preservation of framework-specific state</li>
<li>Improved compatibility with framework features</li>
<li>Enhanced performance through framework-native operations</li>
</ul>
<h2 id="maintainability">Maintainability</h2>
<ul>
<li>Clear separation between framework-specific and generic logic</li>
<li>Pluggable adapter architecture for different frameworks</li>
<li>Testable framework integration components</li>
<li>Extensible design for future framework support</li>
</ul>
<h2 id="user-experience">User Experience</h2>
<ul>
<li>Transparent integration with existing framework usage</li>
<li>No changes required to existing application code</li>
<li>Better error messages for framework-specific issues</li>
<li>Enhanced monitoring and debugging capabilities</li>
</ul>
</body></html>
