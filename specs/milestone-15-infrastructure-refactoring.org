#+TITLE: Milestone 15: Infrastructure Refactoring and Reusability
#+AUTHOR: ByteHot Development Team
#+DATE: 2025-06-27

* Overview

Milestone 15 refactors ByteHot's infrastructure components into a reusable `java-commons-infrastructure` module, enabling future projects and tools to leverage common infrastructure patterns with minimal effort. This refactoring maintains the DDD/Hexagonal architecture principles while extracting reusable base adapters for configuration, events, file system operations, messaging, and monitoring.

** Goals

- Extract reusable infrastructure components from `bytehot-infrastructure` into `java-commons-infrastructure`
- Create base adapter patterns that can be extended for project-specific needs
- Maintain DDD/Hexagonal architecture separation between domain and infrastructure
- Provide comprehensive migration guides for adopting infrastructure patterns
- Enable rapid development of new tools by reusing proven infrastructure components
- Establish clear patterns for primary and secondary port implementations

** User Value Proposition

#+BEGIN_QUOTE
"When I start a new project that needs configuration loading, event handling, or file monitoring, I can leverage battle-tested infrastructure components instead of writing everything from scratch. The base adapters handle common patterns while letting me customize the specific details for my domain."
#+END_QUOTE

* Architecture Overview

** Three-Layer Infrastructure Pattern

#+BEGIN_SRC
┌─────────────────────────────────────────────────────┐
│              Domain Layer (Project-Specific)       │
│   • ByteHot Domain Models                          │
│   • Plugin Domain Models                           │
│   • Business Logic and Rules                       │
│   • Domain Events                                  │
└─────────────────────┬───────────────────────────────┘
                      │ Ports (Interfaces)
                      ▼
┌─────────────────────────────────────────────────────┐
│              Project Infrastructure Layer          │
│   • bytehot-infrastructure                         │
│   • bytehot-plugin-commons                         │
│   • Project-specific adapters                      │
│   • Domain-specific implementations                │
└─────────────────────┬───────────────────────────────┘
                      │ Extends/Composes
                      ▼
┌─────────────────────────────────────────────────────┐
│              Common Infrastructure Layer           │
│   • java-commons-infrastructure                    │
│   • Base adapter patterns                          │
│   • Common infrastructure utilities                │
│   • Reusable testing frameworks                    │
└─────────────────────────────────────────────────────┘
#+END_SRC

** Module Dependencies and Relationships

#+BEGIN_SRC
┌─────────────────────────────────────────────────────┐
│                    Future Projects                  │
│   • New Domain Projects                            │
│   • Plugin Extensions                              │
│   • Tool Integrations                              │
└─────────────────────┬───────────────────────────────┘
                      │ Reuses
                      ▼
┌─────────────────────────────────────────────────────┐
│              java-commons-infrastructure            │
│  ┌─────────────────────────────────────────────────┐ │
│  │          Configuration Management               │ │
│  │  • BaseConfigurationAdapter                    │ │
│  │  • HierarchicalConfigurationLoader             │ │
│  │  │  • ConfigurationSource abstractions         │ │
│  │  • ConfigurationValidation framework           │ │
│  └─────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────┐ │
│  │          Event Infrastructure                   │ │
│  │  • BaseEventEmitterAdapter                     │ │
│  │  • EventSerializationSupport                   │ │
│  │  • EventStoreAdapters                          │ │
│  │  • EventBus implementations                    │ │
│  └─────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────┐ │
│  │          File System Operations                 │ │
│  │  • BaseFileWatcherAdapter                      │ │
│  │  • FileSystemOperations utilities              │ │
│  │  • PathUtils and file management               │ │
│  │  • Directory monitoring patterns               │ │
│  └─────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────┐ │
│  │          Communication Infrastructure           │ │
│  │  • BaseMessageAdapter                          │ │
│  │  • ProtocolHandlers                            │ │
│  │  • ConnectionManagement                        │ │
│  │  • HTTP and WebSocket adapters                 │ │
│  └─────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────┐ │
│  │          Monitoring and Testing                 │ │
│  │  • HealthCheckAdapter                          │ │
│  │  • MetricsCollectionAdapter                    │ │
│  │  • MockAdapterFramework                        │ │
│  │  • TestEnvironmentSetup                        │ │
│  └─────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────┐
│                   java-commons                      │
│   • Base patterns (Port, Adapter, etc.)           │
│   • Domain patterns (DomainEvent, Repository)      │
│   • Utility classes (StringUtils, FileUtils)      │
│   • Common exceptions and validation               │
└─────────────────────────────────────────────────────┘
#+END_SRC

* Phase 1: Module Creation and Base Abstractions

** Objective
Create the foundational `java-commons-infrastructure` module with base adapter patterns that can be extended for project-specific needs while maintaining clear separation between infrastructure concerns and domain logic.

** Module Structure and Dependencies

*** Maven Module Configuration
#+BEGIN_SRC xml
<!-- java-commons-infrastructure/pom.xml -->
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  
  <parent>
    <groupId>org.acmsl</groupId>
    <artifactId>acmsl-pom</artifactId>
    <version>latest-SNAPSHOT</version>
    <relativePath>../pom.xml</relativePath>
  </parent>
  
  <artifactId>java-commons-infrastructure</artifactId>
  <packaging>jar</packaging>
  <name>Java Commons Infrastructure</name>
  <description>Reusable infrastructure components for DDD/Hexagonal architecture projects</description>
  
  <dependencies>
    <!-- Core dependency on java-commons for base patterns -->
    <dependency>
      <groupId>org.acmsl</groupId>
      <artifactId>java-commons</artifactId>
      <version>latest-SNAPSHOT</version>
    </dependency>
    
    <!-- Configuration support -->
    <dependency>
      <groupId>org.yaml</groupId>
      <artifactId>snakeyaml</artifactId>
      <version>2.0</version>
    </dependency>
    
    <!-- JSON support for event serialization -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.15.2</version>
    </dependency>
    
    <!-- HTTP client support -->
    <dependency>
      <groupId>org.apache.httpcomponents.client5</groupId>
      <artifactId>httpclient5</artifactId>
      <version>5.2.1</version>
    </dependency>
    
    <!-- WebSocket support -->
    <dependency>
      <groupId>org.java-websocket</groupId>
      <artifactId>Java-WebSocket</artifactId>
      <version>1.5.3</version>
    </dependency>
    
    <!-- File watching (NIO2 enhanced) -->
    <dependency>
      <groupId>io.methvin</groupId>
      <artifactId>directory-watcher</artifactId>
      <version>0.17.1</version>
    </dependency>
    
    <!-- Testing dependencies -->
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter</artifactId>
      <version>5.9.3</version>
      <scope>test</scope>
    </dependency>
    
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
      <version>5.4.0</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
</project>
#+END_SRC

** Base Configuration Infrastructure

*** ConfigurationSource Hierarchy
#+BEGIN_SRC java
/**
 * Abstract base for different configuration sources in hierarchical loading
 */
public abstract class ConfigurationSource {
    private final int priority;
    private final String name;
    
    protected ConfigurationSource(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    /**
     * Check if this configuration source is available
     */
    public abstract boolean isAvailable();
    
    /**
     * Load configuration from this source
     */
    public abstract Optional<InputStream> loadConfiguration() throws ConfigurationException;
    
    /**
     * Get a description of this configuration source
     */
    public String getName() { return name; }
    
    /**
     * Get the priority of this source (lower numbers = higher priority)
     */
    public int getPriority() { return priority; }
    
    // Concrete implementations
    public static class SystemPropertySource extends ConfigurationSource {
        private final String prefix;
        
        public SystemPropertySource(String prefix) {
            super("System Properties (" + prefix + ")", 10);
            this.prefix = prefix;
        }
        
        @Override
        public boolean isAvailable() {
            return System.getProperties().stringPropertyNames().stream()
                .anyMatch(name -> name.startsWith(prefix));
        }
        
        @Override
        public Optional<InputStream> loadConfiguration() throws ConfigurationException {
            // Convert system properties to configuration format
            Map<String, Object> config = new HashMap<>();
            System.getProperties().stringPropertyNames().stream()
                .filter(name -> name.startsWith(prefix))
                .forEach(name -> {
                    String key = name.substring(prefix.length());
                    config.put(key, System.getProperty(name));
                });
                
            if (config.isEmpty()) {
                return Optional.empty();
            }
            
            try {
                ObjectMapper mapper = new ObjectMapper();
                String json = mapper.writeValueAsString(config);
                return Optional.of(new ByteArrayInputStream(json.getBytes()));
            } catch (Exception e) {
                throw new ConfigurationException("Failed to serialize system properties", e);
            }
        }
    }
    
    public static class EnvironmentVariableSource extends ConfigurationSource {
        private final String prefix;
        
        public EnvironmentVariableSource(String prefix) {
            super("Environment Variables (" + prefix + ")", 20);
            this.prefix = prefix;
        }
        
        @Override
        public boolean isAvailable() {
            return System.getenv().keySet().stream()
                .anyMatch(name -> name.startsWith(prefix));
        }
        
        @Override
        public Optional<InputStream> loadConfiguration() throws ConfigurationException {
            Map<String, Object> config = new HashMap<>();
            System.getenv().entrySet().stream()
                .filter(entry -> entry.getKey().startsWith(prefix))
                .forEach(entry -> {
                    String key = entry.getKey().substring(prefix.length()).toLowerCase().replace("_", ".");
                    config.put(key, entry.getValue());
                });
                
            if (config.isEmpty()) {
                return Optional.empty();
            }
            
            try {
                ObjectMapper mapper = new ObjectMapper();
                String json = mapper.writeValueAsString(config);
                return Optional.of(new ByteArrayInputStream(json.getBytes()));
            } catch (Exception e) {
                throw new ConfigurationException("Failed to serialize environment variables", e);
            }
        }
    }
    
    public static class YamlFileSource extends ConfigurationSource {
        private final String filename;
        private final boolean classpath;
        
        public YamlFileSource(String filename) {
            this(filename, true);
        }
        
        public YamlFileSource(String filename, boolean classpath) {
            super("YAML File (" + filename + ")", classpath ? 30 : 25);
            this.filename = filename;
            this.classpath = classpath;
        }
        
        @Override
        public boolean isAvailable() {
            if (classpath) {
                return getClass().getClassLoader().getResourceAsStream(filename) != null;
            } else {
                return Files.exists(Paths.get(filename));
            }
        }
        
        @Override
        public Optional<InputStream> loadConfiguration() throws ConfigurationException {
            try {
                if (classpath) {
                    InputStream stream = getClass().getClassLoader().getResourceAsStream(filename);
                    return Optional.ofNullable(stream);
                } else {
                    return Optional.of(Files.newInputStream(Paths.get(filename)));
                }
            } catch (IOException e) {
                throw new ConfigurationException("Failed to load YAML file: " + filename, e);
            }
        }
    }
    
    public static class DefaultConfigurationSource extends ConfigurationSource {
        private final Supplier<InputStream> defaultSupplier;
        
        public DefaultConfigurationSource(Supplier<InputStream> defaultSupplier) {
            super("Default Configuration", 100);
            this.defaultSupplier = defaultSupplier;
        }
        
        @Override
        public boolean isAvailable() {
            return true; // Always available as fallback
        }
        
        @Override
        public Optional<InputStream> loadConfiguration() throws ConfigurationException {
            try {
                return Optional.ofNullable(defaultSupplier.get());
            } catch (Exception e) {
                throw new ConfigurationException("Failed to create default configuration", e);
            }
        }
    }
}
#+END_SRC

*** BaseConfigurationAdapter
#+BEGIN_SRC java
/**
 * Base adapter for configuration loading with hierarchical source support.
 * Projects can extend this to provide domain-specific configuration handling.
 */
public abstract class BaseConfigurationAdapter implements Port {
    
    private static final Logger LOG = LoggerFactory.getLogger(BaseConfigurationAdapter.class);
    
    private final List<ConfigurationSource> configurationSources;
    private final ConfigurationValidator validator;
    private volatile Object cachedConfiguration;
    private volatile long lastLoadTime = 0;
    private static final long CACHE_TTL_MS = 300_000; // 5 minutes
    
    protected BaseConfigurationAdapter() {
        this.configurationSources = createConfigurationSources();
        this.validator = createConfigurationValidator();
        
        // Sort sources by priority
        this.configurationSources.sort(Comparator.comparingInt(ConfigurationSource::getPriority));
    }
    
    /**
     * Template method for subclasses to define their configuration sources
     */
    protected abstract List<ConfigurationSource> createConfigurationSources();
    
    /**
     * Template method for subclasses to define their configuration validator
     */
    protected abstract ConfigurationValidator createConfigurationValidator();
    
    /**
     * Template method for subclasses to parse configuration from InputStream
     */
    protected abstract Object parseConfiguration(InputStream source, String sourceName) 
        throws ConfigurationException;
    
    /**
     * Template method for subclasses to create default configuration
     */
    protected abstract Object createDefaultConfiguration();
    
    /**
     * Main configuration loading algorithm - final to ensure consistent behavior
     */
    public final Object loadConfiguration() throws ConfigurationException {
        // Check cache validity
        if (isCacheValid()) {
            LOG.debug("Returning cached configuration");
            return cachedConfiguration;
        }
        
        LOG.info("Loading configuration from {} sources", configurationSources.size());
        
        // Try each configuration source in priority order
        for (ConfigurationSource source : configurationSources) {
            try {
                if (!source.isAvailable()) {
                    LOG.debug("Configuration source not available: {}", source.getName());
                    continue;
                }
                
                LOG.debug("Attempting to load configuration from: {}", source.getName());
                Optional<InputStream> configStream = source.loadConfiguration();
                
                if (configStream.isPresent()) {
                    try (InputStream stream = configStream.get()) {
                        Object config = parseConfiguration(stream, source.getName());
                        
                        // Validate configuration
                        ValidationResult validationResult = validator.validate(config);
                        if (!validationResult.isValid()) {
                            LOG.warn("Configuration from {} failed validation: {}", 
                                   source.getName(), validationResult.getErrorMessage());
                            continue;
                        }
                        
                        // Configuration loaded successfully
                        LOG.info("Configuration loaded successfully from: {}", source.getName());
                        updateCache(config);
                        return config;
                    }
                }
            } catch (Exception e) {
                LOG.warn("Failed to load configuration from {}: {}", source.getName(), e.getMessage());
                // Continue to next source
            }
        }
        
        // No configuration found, use default
        LOG.info("No valid configuration found, using default configuration");
        Object defaultConfig = createDefaultConfiguration();
        updateCache(defaultConfig);
        return defaultConfig;
    }
    
    /**
     * Force reload of configuration, bypassing cache
     */
    public final Object reloadConfiguration() throws ConfigurationException {
        clearCache();
        return loadConfiguration();
    }
    
    /**
     * Check if configuration is available from any source
     */
    public boolean isConfigurationAvailable() {
        return configurationSources.stream().anyMatch(ConfigurationSource::isAvailable);
    }
    
    /**
     * Get description of configuration source that would be used
     */
    public String getConfigurationSource() {
        return configurationSources.stream()
            .filter(ConfigurationSource::isAvailable)
            .findFirst()
            .map(ConfigurationSource::getName)
            .orElse("Default Configuration");
    }
    
    /**
     * Add a custom configuration source at runtime
     */
    public void addConfigurationSource(ConfigurationSource source) {
        configurationSources.add(source);
        configurationSources.sort(Comparator.comparingInt(ConfigurationSource::getPriority));
        clearCache(); // Force reload
    }
    
    private boolean isCacheValid() {
        return cachedConfiguration != null && 
               (System.currentTimeMillis() - lastLoadTime) < CACHE_TTL_MS;
    }
    
    private void updateCache(Object configuration) {
        this.cachedConfiguration = configuration;
        this.lastLoadTime = System.currentTimeMillis();
    }
    
    private void clearCache() {
        this.cachedConfiguration = null;
        this.lastLoadTime = 0;
    }
}
#+END_SRC

** Base Event Infrastructure

*** BaseEventEmitterAdapter
#+BEGIN_SRC java
/**
 * Base adapter for event emission with multiple targets and serialization support
 */
public abstract class BaseEventEmitterAdapter implements Port {
    
    private static final Logger LOG = LoggerFactory.getLogger(BaseEventEmitterAdapter.class);
    
    private final List<EmissionTarget> emissionTargets;
    private final EventSerializer eventSerializer;
    private final EventBus eventBus;
    private final ExecutorService asyncExecutor;
    
    protected BaseEventEmitterAdapter() {
        this.emissionTargets = createEmissionTargets();
        this.eventSerializer = createEventSerializer();
        this.eventBus = createEventBus();
        this.asyncExecutor = Executors.newCachedThreadPool(
            new NamedThreadFactory("EventEmitter"));
    }
    
    /**
     * Template method for subclasses to define their emission targets
     */
    protected abstract List<EmissionTarget> createEmissionTargets();
    
    /**
     * Template method for subclasses to define their event serializer
     */
    protected abstract EventSerializer createEventSerializer();
    
    /**
     * Template method for subclasses to define their event bus
     */
    protected abstract EventBus createEventBus();
    
    /**
     * Emit event synchronously to all targets
     */
    public final void emit(DomainEvent event) {
        LOG.debug("Emitting event synchronously: {}", event.getClass().getSimpleName());
        
        try {
            // Serialize event once
            String serializedEvent = eventSerializer.serialize(event);
            
            // Emit to local event bus first
            eventBus.publish(event);
            
            // Emit to external targets
            for (EmissionTarget target : emissionTargets) {
                try {
                    if (target.isAvailable()) {
                        target.emit(serializedEvent, event);
                    } else {
                        LOG.warn("Emission target not available: {}", target.getName());
                    }
                } catch (Exception e) {
                    LOG.error("Failed to emit to target {}: {}", target.getName(), e.getMessage());
                    handleEmissionFailure(target, event, e);
                }
            }
            
        } catch (Exception e) {
            LOG.error("Failed to emit event: {}", event.getClass().getSimpleName(), e);
            throw new EventEmissionException("Event emission failed", e);
        }
    }
    
    /**
     * Emit event asynchronously to all targets
     */
    public final CompletableFuture<Void> emitAsync(DomainEvent event) {
        LOG.debug("Emitting event asynchronously: {}", event.getClass().getSimpleName());
        
        return CompletableFuture.runAsync(() -> emit(event), asyncExecutor);
    }
    
    /**
     * Emit multiple events in batch
     */
    public final void emitBatch(List<DomainEvent> events) {
        LOG.debug("Emitting {} events in batch", events.size());
        
        try {
            // Serialize all events
            List<String> serializedEvents = events.stream()
                .map(event -> {
                    try {
                        return eventSerializer.serialize(event);
                    } catch (Exception e) {
                        LOG.error("Failed to serialize event: {}", event.getClass().getSimpleName(), e);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
            
            // Emit to local event bus
            events.forEach(eventBus::publish);
            
            // Emit to external targets
            for (EmissionTarget target : emissionTargets) {
                try {
                    if (target.isAvailable() && target.supportsBatch()) {
                        target.emitBatch(serializedEvents, events);
                    } else if (target.isAvailable()) {
                        // Fallback to individual emissions
                        for (int i = 0; i < events.size() && i < serializedEvents.size(); i++) {
                            target.emit(serializedEvents.get(i), events.get(i));
                        }
                    }
                } catch (Exception e) {
                    LOG.error("Failed to emit batch to target {}: {}", target.getName(), e.getMessage());
                    handleBatchEmissionFailure(target, events, e);
                }
            }
            
        } catch (Exception e) {
            LOG.error("Failed to emit event batch", e);
            throw new EventEmissionException("Batch event emission failed", e);
        }
    }
    
    /**
     * Add emission target at runtime
     */
    public void addEmissionTarget(EmissionTarget target) {
        emissionTargets.add(target);
        LOG.info("Added emission target: {}", target.getName());
    }
    
    /**
     * Remove emission target
     */
    public boolean removeEmissionTarget(String targetName) {
        boolean removed = emissionTargets.removeIf(target -> target.getName().equals(targetName));
        if (removed) {
            LOG.info("Removed emission target: {}", targetName);
        }
        return removed;
    }
    
    /**
     * Get status of all emission targets
     */
    public Map<String, Boolean> getTargetStatus() {
        return emissionTargets.stream()
            .collect(Collectors.toMap(
                EmissionTarget::getName,
                EmissionTarget::isAvailable
            ));
    }
    
    /**
     * Template method for handling emission failures
     */
    protected void handleEmissionFailure(EmissionTarget target, DomainEvent event, Exception error) {
        // Default implementation - subclasses can override for custom handling
        LOG.error("Event emission failed for target {} with event {}: {}", 
                 target.getName(), event.getClass().getSimpleName(), error.getMessage());
    }
    
    /**
     * Template method for handling batch emission failures
     */
    protected void handleBatchEmissionFailure(EmissionTarget target, List<DomainEvent> events, Exception error) {
        // Default implementation - subclasses can override for custom handling
        LOG.error("Batch event emission failed for target {} with {} events: {}", 
                 target.getName(), events.size(), error.getMessage());
    }
    
    /**
     * Cleanup resources
     */
    public void shutdown() {
        try {
            asyncExecutor.shutdown();
            if (!asyncExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                asyncExecutor.shutdownNow();
            }
            
            // Close emission targets
            emissionTargets.forEach(target -> {
                try {
                    target.close();
                } catch (Exception e) {
                    LOG.warn("Failed to close emission target {}: {}", target.getName(), e.getMessage());
                }
            });
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            asyncExecutor.shutdownNow();
        }
    }
}

/**
 * Interface for event emission targets
 */
public interface EmissionTarget extends AutoCloseable {
    String getName();
    boolean isAvailable();
    boolean supportsBatch();
    void emit(String serializedEvent, DomainEvent originalEvent) throws EmissionException;
    default void emitBatch(List<String> serializedEvents, List<DomainEvent> originalEvents) throws EmissionException {
        for (int i = 0; i < serializedEvents.size(); i++) {
            emit(serializedEvents.get(i), originalEvents.get(i));
        }
    }
}
#+END_SRC

** Implementation Tasks

*** Module Setup
1. Create `java-commons-infrastructure` Maven module with proper dependencies
2. Set up package structure for different infrastructure domains
3. Configure build plugins for testing and documentation
4. Update parent POM to include new module

*** Base Adapter Implementation
1. Implement `BaseConfigurationAdapter` with hierarchical loading
2. Implement `BaseEventEmitterAdapter` with multiple targets
3. Implement `BaseFileWatcherAdapter` with cross-platform support
4. Implement `BaseMessageAdapter` for protocol communication

*** Infrastructure Utilities
1. Create `ConfigurationSource` hierarchy for different config sources
2. Create `EmissionTarget` implementations for files, HTTP, databases
3. Create `FileSystemOperations` utilities for common file operations
4. Create `ProtocolHandlers` for message-based communication

** Acceptance Criteria

- [ ] `java-commons-infrastructure` module created with proper Maven configuration
- [ ] Base adapter patterns provide 80% of common functionality out-of-the-box
- [ ] Configuration loading supports system properties, environment variables, YAML files, and defaults
- [ ] Event emission supports multiple targets with failure handling and retry logic
- [ ] File watching supports cross-platform monitoring with configurable patterns
- [ ] All base adapters include comprehensive unit tests
- [ ] Documentation explains when to use base vs custom adapters
- [ ] Migration guide shows how to refactor existing adapters

* Phase 2: ByteHot Infrastructure Refactoring

** Objective
Refactor existing ByteHot infrastructure components to use the new base adapters while maintaining all current functionality and improving code reusability.

** Refactoring Strategy

*** Configuration Adapter Refactoring
#+BEGIN_SRC java
/**
 * Refactored ByteHot configuration adapter using base infrastructure
 */
public class ByteHotConfigurationAdapter extends BaseConfigurationAdapter 
    implements ConfigurationPort, Adapter<ConfigurationPort> {
    
    @Override
    protected List<ConfigurationSource> createConfigurationSources() {
        return Arrays.asList(
            new SystemPropertySource("bytehot."),
            new EnvironmentVariableSource("BYTEHOT_"),
            new YamlFileSource("bytehot.yml"),
            new YamlFileSource("bytehot.yaml"),
            new DefaultConfigurationSource(this::createDefaultByteHotConfiguration)
        );
    }
    
    @Override
    protected ConfigurationValidator createConfigurationValidator() {
        return new ByteHotConfigurationValidator();
    }
    
    @Override
    protected Object parseConfiguration(InputStream source, String sourceName) 
        throws ConfigurationException {
        try {
            if (sourceName.contains("System Properties") || sourceName.contains("Environment")) {
                // JSON format from converted properties/env vars
                ObjectMapper mapper = new ObjectMapper();
                return mapper.readValue(source, ByteHotConfiguration.class);
            } else {
                // YAML format
                Yaml yaml = new Yaml();
                Map<String, Object> data = yaml.load(source);
                return convertToByteHotConfiguration(data);
            }
        } catch (Exception e) {
            throw new ConfigurationException("Failed to parse configuration from " + sourceName, e);
        }
    }
    
    @Override
    protected Object createDefaultConfiguration() {
        return createDefaultByteHotConfiguration();
    }
    
    /**
     * ByteHot-specific configuration creation
     */
    private InputStream createDefaultByteHotConfiguration() {
        String defaultYaml = """
            bytehot:
              watch:
                - path: "target/classes"
                  patterns: ["*.class"]
                  recursive: true
                - path: "build/classes"
                  patterns: ["*.class"]
                  recursive: true
              port: 8080
            """;
        return new ByteArrayInputStream(defaultYaml.getBytes());
    }
    
    private ByteHotConfiguration convertToByteHotConfiguration(Map<String, Object> data) {
        // Convert YAML data to ByteHot domain configuration
        // Implementation specific to ByteHot needs
    }
    
    // Implement ConfigurationPort methods by delegating to base class
    @Override
    public WatchConfiguration loadWatchConfiguration() throws Exception {
        ByteHotConfiguration config = (ByteHotConfiguration) loadConfiguration();
        return convertToWatchConfiguration(config);
    }
    
    @Override
    public boolean isConfigurationAvailable() {
        return super.isConfigurationAvailable();
    }
    
    @Override
    public String getConfigurationSource() {
        return super.getConfigurationSource();
    }
    
    @Override
    public Class<ConfigurationPort> adapts() {
        return ConfigurationPort.class;
    }
}
#+END_SRC

*** Event Emitter Adapter Refactoring
#+BEGIN_SRC java
/**
 * Refactored ByteHot event emitter using base infrastructure
 */
public class ByteHotEventEmitterAdapter extends BaseEventEmitterAdapter 
    implements EventEmitterPort, Adapter<EventEmitterPort> {
    
    @Override
    protected List<EmissionTarget> createEmissionTargets() {
        List<EmissionTarget> targets = new ArrayList<>();
        
        // File-based emission target for persistence
        targets.add(new FileEmissionTarget("event-store", Paths.get("eventstore")));
        
        // HTTP emission target for external systems
        String httpEndpoint = System.getProperty("bytehot.events.http.endpoint");
        if (httpEndpoint != null) {
            targets.add(new HttpEmissionTarget("http-endpoint", httpEndpoint));
        }
        
        // Database emission target if configured
        String dbUrl = System.getProperty("bytehot.events.database.url");
        if (dbUrl != null) {
            targets.add(new DatabaseEmissionTarget("database", dbUrl));
        }
        
        return targets;
    }
    
    @Override
    protected EventSerializer createEventSerializer() {
        return new JsonEventSerializer();
    }
    
    @Override
    protected EventBus createEventBus() {
        return new SimpleEventBus();
    }
    
    // Implement EventEmitterPort methods by delegating to base class
    @Override
    public void emit(DomainEvent event) {
        super.emit(event);
    }
    
    @Override
    public void emitAsync(DomainEvent event) {
        super.emitAsync(event);
    }
    
    @Override
    public Class<EventEmitterPort> adapts() {
        return EventEmitterPort.class;
    }
    
    /**
     * ByteHot-specific emission failure handling
     */
    @Override
    protected void handleEmissionFailure(EmissionTarget target, DomainEvent event, Exception error) {
        super.handleEmissionFailure(target, event, error);
        
        // ByteHot-specific handling: log to ByteHot error tracking
        if (target instanceof FileEmissionTarget) {
            // Try alternative file location
            tryAlternativeFileLocation(event, error);
        } else if (target instanceof HttpEmissionTarget) {
            // Queue for retry
            queueForRetry(event, error);
        }
    }
}
#+END_SRC

** Implementation Tasks

*** Adapter Refactoring
1. Refactor `ConfigurationAdapter` to extend `BaseConfigurationAdapter`
2. Refactor `EventEmitterAdapter` to extend `BaseEventEmitterAdapter`
3. Refactor `FileWatcherAdapter` to extend `BaseFileWatcherAdapter`
4. Update all imports and dependency injection

*** Preserve Existing Functionality
1. Ensure all existing configuration sources still work
2. Maintain backward compatibility for event emission
3. Keep all file watching patterns and behavior
4. Preserve performance characteristics

*** Testing Migration
1. Update unit tests to work with refactored adapters
2. Add integration tests for base adapter functionality
3. Performance testing to ensure no regressions
4. Compatibility testing with existing configurations

** Acceptance Criteria

- [ ] All ByteHot infrastructure adapters use base infrastructure components
- [ ] Existing functionality is preserved with no breaking changes
- [ ] Code duplication reduced by at least 60% in infrastructure components
- [ ] Performance is maintained or improved
- [ ] All existing tests pass without modification
- [ ] New base adapter features are available to ByteHot components

* Phase 3: Plugin Integration and Enhancement

** Objective
Update the ByteHot plugin ecosystem to leverage the new infrastructure components, demonstrating how future projects can rapidly build infrastructure by reusing proven patterns.

** Plugin Infrastructure Updates

*** Plugin Commons Enhancement
#+BEGIN_SRC java
/**
 * Enhanced plugin configuration using base infrastructure
 */
public class PluginConfigurationAdapter extends BaseConfigurationAdapter {
    
    private final String pluginId;
    private final PluginType pluginType;
    
    public PluginConfigurationAdapter(String pluginId, PluginType pluginType) {
        super();
        this.pluginId = pluginId;
        this.pluginType = pluginType;
    }
    
    @Override
    protected List<ConfigurationSource> createConfigurationSources() {
        List<ConfigurationSource> sources = new ArrayList<>();
        
        // Plugin-specific system properties
        sources.add(new SystemPropertySource("bytehot.plugin." + pluginId + "."));
        
        // Plugin-specific environment variables
        sources.add(new EnvironmentVariableSource("BYTEHOT_PLUGIN_" + pluginId.toUpperCase() + "_"));
        
        // Tool-specific configuration files
        switch (pluginType) {
            case MAVEN:
                sources.add(new MavenPomConfigurationSource());
                break;
            case GRADLE:
                sources.add(new GradleBuildConfigurationSource());
                break;
            case INTELLIJ:
                sources.add(new IntellijConfigurationSource());
                break;
            case ECLIPSE:
                sources.add(new EclipseConfigurationSource());
                break;
            case VSCODE:
                sources.add(new VSCodeConfigurationSource());
                break;
        }
        
        // Common plugin configuration files
        sources.add(new YamlFileSource(".bytehot/plugin-" + pluginId + ".yml"));
        sources.add(new YamlFileSource(".bytehot/config.yml"));
        
        // Default plugin configuration
        sources.add(new DefaultConfigurationSource(this::createDefaultPluginConfiguration));
        
        return sources;
    }
    
    @Override
    protected ConfigurationValidator createConfigurationValidator() {
        return new PluginConfigurationValidator(pluginType);
    }
    
    @Override
    protected Object parseConfiguration(InputStream source, String sourceName) 
        throws ConfigurationException {
        
        try {
            if (sourceName.contains("Maven POM")) {
                return parseMavenConfiguration(source);
            } else if (sourceName.contains("Gradle Build")) {
                return parseGradleConfiguration(source);
            } else if (sourceName.contains("IntelliJ")) {
                return parseIntellijConfiguration(source);
            } else {
                // Standard YAML/JSON parsing
                return parseStandardConfiguration(source, sourceName);
            }
        } catch (Exception e) {
            throw new ConfigurationException("Failed to parse plugin configuration from " + sourceName, e);
        }
    }
    
    @Override
    protected Object createDefaultConfiguration() {
        return createDefaultPluginConfiguration();
    }
    
    private PluginConfiguration createDefaultPluginConfiguration() {
        return PluginConfiguration.builder()
            .setPluginId(pluginId)
            .setPluginType(pluginType)
            .setAutoStart(false)
            .setDebugMode(false)
            .addConfigurationSources(getDefaultConfigurationSources())
            .build();
    }
}
#+END_SRC

*** Tool-Specific Configuration Sources
#+BEGIN_SRC java
/**
 * Maven POM configuration source for plugin settings
 */
public class MavenPomConfigurationSource extends ConfigurationSource {
    
    public MavenPomConfigurationSource() {
        super("Maven POM Configuration", 15);
    }
    
    @Override
    public boolean isAvailable() {
        return Files.exists(Paths.get("pom.xml"));
    }
    
    @Override
    public Optional<InputStream> loadConfiguration() throws ConfigurationException {
        try {
            Path pomPath = Paths.get("pom.xml");
            if (!Files.exists(pomPath)) {
                return Optional.empty();
            }
            
            // Parse POM XML to extract ByteHot plugin configuration
            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
            Document doc = builder.parse(pomPath.toFile());
            
            // Find ByteHot plugin configuration
            NodeList plugins = doc.getElementsByTagName("plugin");
            for (int i = 0; i < plugins.getLength(); i++) {
                Element plugin = (Element) plugins.item(i);
                
                String groupId = getElementText(plugin, "groupId");
                String artifactId = getElementText(plugin, "artifactId");
                
                if ("org.acmsl".equals(groupId) && "bytehot-maven-plugin".equals(artifactId)) {
                    Element configuration = (Element) plugin.getElementsByTagName("configuration").item(0);
                    if (configuration != null) {
                        return Optional.of(convertPomConfigurationToJson(configuration));
                    }
                }
            }
            
            return Optional.empty();
            
        } catch (Exception e) {
            throw new ConfigurationException("Failed to load Maven POM configuration", e);
        }
    }
    
    private InputStream convertPomConfigurationToJson(Element configuration) throws Exception {
        Map<String, Object> config = new HashMap<>();
        
        // Convert XML configuration to JSON format
        NodeList children = configuration.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            if (child.getNodeType() == Node.ELEMENT_NODE) {
                Element element = (Element) child;
                String key = convertXmlNameToJsonKey(element.getTagName());
                Object value = extractElementValue(element);
                config.put(key, value);
            }
        }
        
        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(config);
        return new ByteArrayInputStream(json.getBytes());
    }
}

/**
 * Gradle build configuration source for plugin settings
 */
public class GradleBuildConfigurationSource extends ConfigurationSource {
    
    public GradleBuildConfigurationSource() {
        super("Gradle Build Configuration", 15);
    }
    
    @Override
    public boolean isAvailable() {
        return Files.exists(Paths.get("build.gradle")) || 
               Files.exists(Paths.get("build.gradle.kts"));
    }
    
    @Override
    public Optional<InputStream> loadConfiguration() throws ConfigurationException {
        try {
            // Check for Kotlin DSL first
            Path buildFile = Files.exists(Paths.get("build.gradle.kts")) 
                ? Paths.get("build.gradle.kts")
                : Paths.get("build.gradle");
                
            if (!Files.exists(buildFile)) {
                return Optional.empty();
            }
            
            String buildContent = Files.readString(buildFile);
            
            // Extract bytehot configuration block
            String bytehotConfig = extractByteHotConfigurationBlock(buildContent);
            if (bytehotConfig != null) {
                return Optional.of(convertGradleConfigToJson(bytehotConfig));
            }
            
            return Optional.empty();
            
        } catch (Exception e) {
            throw new ConfigurationException("Failed to load Gradle build configuration", e);
        }
    }
    
    private String extractByteHotConfigurationBlock(String buildContent) {
        // Parse Gradle build file to extract bytehot configuration block
        // This is a simplified implementation - real version would use proper Gradle parsing
        Pattern pattern = Pattern.compile("bytehot\\s*\\{([^}]*)\\}", Pattern.DOTALL);
        Matcher matcher = pattern.matcher(buildContent);
        
        if (matcher.find()) {
            return matcher.group(1);
        }
        
        return null;
    }
    
    private InputStream convertGradleConfigToJson(String gradleConfig) throws Exception {
        // Convert Gradle DSL configuration to JSON format
        // This is a simplified implementation
        Map<String, Object> config = parseGradleDSL(gradleConfig);
        
        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(config);
        return new ByteArrayInputStream(json.getBytes());
    }
}
#+END_SRC

** Implementation Tasks

*** Plugin Infrastructure
1. Update `bytehot-plugin-commons` to use base infrastructure components
2. Create tool-specific configuration sources for each plugin type
3. Implement plugin-specific adapters using base patterns
4. Add plugin infrastructure testing utilities

*** Plugin Updates
1. Update Maven plugin to use enhanced configuration infrastructure
2. Update Gradle plugin to use enhanced configuration infrastructure
3. Update IDE plugins to use base communication infrastructure
4. Ensure all plugins benefit from improved infrastructure

*** Documentation Updates
1. Update plugin development guide to show base infrastructure usage
2. Create examples of extending base adapters for new tools
3. Document configuration source priorities and interactions
4. Provide troubleshooting guide for configuration issues

** Acceptance Criteria

- [ ] All ByteHot plugins use base infrastructure components
- [ ] Plugin development time reduced by 50% for new tool integrations
- [ ] Configuration loading is consistent across all plugin types
- [ ] Tool-specific configuration sources work seamlessly with base infrastructure
- [ ] Plugin infrastructure testing is simplified and more reliable
- [ ] Documentation enables easy creation of new plugins

* Phase 4: Documentation and Migration Framework

** Objective
Create comprehensive documentation and migration tools that enable future projects to quickly adopt the infrastructure patterns and help existing projects migrate to the new architecture.

** Migration Guide Structure

*** Infrastructure Patterns Guide
Create `specs/technical-specs/infrastructure-patterns-guide.org` with:

1. **Base Adapter Patterns**
   - When to use base adapters vs custom implementations
   - Extension points and customization strategies
   - Common pitfalls and best practices

2. **Configuration Infrastructure**
   - Hierarchical configuration loading patterns
   - Creating custom configuration sources
   - Validation and error handling strategies

3. **Event Infrastructure**
   - Event emission patterns and targets
   - Serialization strategies and formats
   - Failure handling and retry mechanisms

4. **Communication Infrastructure**
   - Protocol handler patterns
   - Connection management strategies
   - Testing communication infrastructure

*** Adapter Migration Guide
Create `specs/migration-guides/adapter-migration-guide.org` with:

1. **Migration Checklist**
   - Pre-migration assessment
   - Step-by-step migration process
   - Post-migration validation

2. **Code Examples**
   - Before/after comparisons
   - Common migration patterns
   - Tool-specific adaptations

3. **Testing Migration**
   - Test migration strategies
   - Validation approaches
   - Performance testing

** Migration Tools and Utilities

*** Adapter Analysis Tool
#+BEGIN_SRC java
/**
 * Tool to analyze existing adapters and suggest migration paths
 */
public class AdapterMigrationAnalyzer {
    
    public MigrationReport analyzeAdapter(Class<?> adapterClass) {
        MigrationReport.Builder report = MigrationReport.builder(adapterClass);
        
        // Analyze current implementation
        analyzeCurrentImplementation(adapterClass, report);
        
        // Suggest base adapter match
        suggestBaseAdapterMatch(adapterClass, report);
        
        // Identify migration complexity
        assessMigrationComplexity(adapterClass, report);
        
        // Generate migration recommendations
        generateMigrationRecommendations(adapterClass, report);
        
        return report.build();
    }
    
    private void analyzeCurrentImplementation(Class<?> adapterClass, MigrationReport.Builder report) {
        // Analyze existing code structure
        report.addAnalysis("Current Implementation", analyzeImplementationPatterns(adapterClass));
        
        // Identify reusable components
        report.addAnalysis("Reusable Components", identifyReusableComponents(adapterClass));
        
        // Identify custom logic
        report.addAnalysis("Custom Logic", identifyCustomLogic(adapterClass));
    }
    
    private void suggestBaseAdapterMatch(Class<?> adapterClass, MigrationReport.Builder report) {
        // Determine best base adapter match
        String adapterName = adapterClass.getSimpleName();
        
        if (adapterName.contains("Configuration")) {
            report.addRecommendation("Use BaseConfigurationAdapter", 
                "Extend BaseConfigurationAdapter for hierarchical configuration loading");
        } else if (adapterName.contains("Event")) {
            report.addRecommendation("Use BaseEventEmitterAdapter",
                "Extend BaseEventEmitterAdapter for multi-target event emission");
        } else if (adapterName.contains("FileWatcher") || adapterName.contains("File")) {
            report.addRecommendation("Use BaseFileWatcherAdapter",
                "Extend BaseFileWatcherAdapter for cross-platform file monitoring");
        }
    }
}
#+END_SRC

*** Migration Template Generator
#+BEGIN_SRC java
/**
 * Generates migration templates for different adapter types
 */
public class MigrationTemplateGenerator {
    
    public String generateConfigurationAdapterTemplate(String projectName, String domainName) {
        return String.format("""
            /**
             * %s configuration adapter using base infrastructure
             */
            public class %sConfigurationAdapter extends BaseConfigurationAdapter 
                implements ConfigurationPort, Adapter<ConfigurationPort> {
                
                @Override
                protected List<ConfigurationSource> createConfigurationSources() {
                    return Arrays.asList(
                        new SystemPropertySource("%s."),
                        new EnvironmentVariableSource("%s_"),
                        new YamlFileSource("%s.yml"),
                        new DefaultConfigurationSource(this::createDefault%sConfiguration)
                    );
                }
                
                @Override
                protected ConfigurationValidator createConfigurationValidator() {
                    return new %sConfigurationValidator();
                }
                
                @Override
                protected Object parseConfiguration(InputStream source, String sourceName) 
                    throws ConfigurationException {
                    // TODO: Implement %s-specific configuration parsing
                    throw new UnsupportedOperationException("Not yet implemented");
                }
                
                @Override
                protected Object createDefaultConfiguration() {
                    // TODO: Create default %s configuration
                    throw new UnsupportedOperationException("Not yet implemented");
                }
                
                @Override
                public Class<ConfigurationPort> adapts() {
                    return ConfigurationPort.class;
                }
                
                private InputStream createDefault%sConfiguration() {
                    // TODO: Implement default configuration creation
                    throw new UnsupportedOperationException("Not yet implemented");
                }
            }
            """, 
            projectName, domainName, 
            projectName.toLowerCase(), projectName.toUpperCase(),
            projectName.toLowerCase(), domainName,
            domainName, domainName, domainName, domainName);
    }
    
    public String generateEventEmitterAdapterTemplate(String projectName, String domainName) {
        return String.format("""
            /**
             * %s event emitter adapter using base infrastructure
             */
            public class %sEventEmitterAdapter extends BaseEventEmitterAdapter 
                implements EventEmitterPort, Adapter<EventEmitterPort> {
                
                @Override
                protected List<EmissionTarget> createEmissionTargets() {
                    List<EmissionTarget> targets = new ArrayList<>();
                    
                    // TODO: Add %s-specific emission targets
                    targets.add(new FileEmissionTarget("%s-events", Paths.get("events")));
                    
                    return targets;
                }
                
                @Override
                protected EventSerializer createEventSerializer() {
                    return new JsonEventSerializer();
                }
                
                @Override
                protected EventBus createEventBus() {
                    return new SimpleEventBus();
                }
                
                @Override
                public Class<EventEmitterPort> adapts() {
                    return EventEmitterPort.class;
                }
                
                @Override
                protected void handleEmissionFailure(EmissionTarget target, DomainEvent event, Exception error) {
                    super.handleEmissionFailure(target, event, error);
                    
                    // TODO: Add %s-specific failure handling
                }
            }
            """, 
            projectName, domainName, projectName, projectName.toLowerCase(), projectName);
    }
}
#+END_SRC

** Implementation Tasks

*** Documentation Creation
1. Create comprehensive infrastructure patterns guide
2. Create step-by-step migration guide with examples
3. Create troubleshooting documentation for common issues
4. Create best practices guide for infrastructure development

*** Migration Tools
1. Implement adapter analysis tool for migration assessment
2. Create migration template generator for common patterns
3. Build validation tools for migration verification
4. Create performance comparison tools

*** Examples and Tutorials
1. Create complete migration example for a sample project
2. Build tutorial series for different adapter types
3. Create video tutorials for complex migration scenarios
4. Build interactive migration guide

** Acceptance Criteria

- [ ] Infrastructure patterns guide covers all base adapter types
- [ ] Migration guide enables 90% self-service migration
- [ ] Migration tools reduce manual effort by 70%
- [ ] Documentation includes working examples for all patterns
- [ ] Troubleshooting guide covers common migration issues
- [ ] Performance comparison shows infrastructure benefits

* Success Metrics

** Technical Success Criteria
- **Code Reuse**: 80%+ of infrastructure code reused across projects
- **Development Speed**: 50%+ reduction in infrastructure setup time for new projects
- **Consistency**: All adapters follow common patterns and interfaces
- **Performance**: No regression in infrastructure performance after migration
- **Test Coverage**: 90%+ test coverage for all base infrastructure components

** Developer Experience Metrics
- **Migration Success Rate**: 95%+ of adapters successfully migrated without issues
- **Documentation Satisfaction**: 4.5/5 rating for migration documentation
- **Time to Productivity**: New developers productive with infrastructure in <2 days
- **Community Adoption**: External projects adopt infrastructure patterns

** Ecosystem Health Metrics
- **Infrastructure Consistency**: All ByteHot components use base infrastructure
- **Maintenance Overhead**: 60%+ reduction in infrastructure maintenance effort
- **Bug Reduction**: 70%+ reduction in infrastructure-related bugs
- **Future Extensibility**: New infrastructure features benefit all components

* Risk Analysis & Mitigation

** Technical Risks
- *Migration Complexity*: Comprehensive testing and gradual migration approach
- *Performance Impact*: Continuous benchmarking and optimization
- *Breaking Changes*: Careful API design and backward compatibility
- *Infrastructure Dependencies*: Clear dependency management and isolation

** Project Risks
- *Migration Effort*: Automated migration tools and clear guidance
- *Documentation Quality*: Community review and iterative improvement
- *Adoption Resistance*: Clear benefits demonstration and gradual migration
- *Maintenance Burden*: Automated testing and community contribution

* Future Enhancements

** Planned Infrastructure Features
- Enhanced monitoring and observability adapters
- Cloud-native infrastructure adapters (Kubernetes, Docker)
- Database adapter patterns for different storage types
- Message queue adapter patterns for distributed systems

** Community Growth Initiatives
- Infrastructure pattern library with community contributions
- Regular infrastructure improvement proposals
- Training programs for infrastructure development
- Conference presentations on reusable infrastructure patterns

This milestone establishes java-commons-infrastructure as a foundational module that enables rapid development of robust, maintainable infrastructure components while preserving the clean architecture principles that make ByteHot successful.